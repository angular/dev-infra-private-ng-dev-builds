/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { getStatusesForPullRequest, PullRequestStatus, } from '../fetch-pull-request.js';
import { createPullRequestValidation, PullRequestValidation } from './validation-config.js';
/** Assert the pull request has a passing combined CI status. */
// TODO: update typings to make sure portability is properly handled for windows build.
export const passingCiValidation = createPullRequestValidation({ name: 'assertPassingCi', canBeForceIgnored: true }, () => Validation);
class Validation extends PullRequestValidation {
    assert(pullRequest) {
        const { combinedStatus, statuses } = getStatusesForPullRequest(pullRequest);
        // TODO(josephperrott): Find a way to not need to do this kind of detection.
        // Because its not possible to determine if workflow is pending approval or if all checks and
        // statuses have run, we use the `CI / lint (pull_request)` as a marker for if the expected
        // checks have run already.  If they have not yet run, we mark the combined status as missing.
        if (statuses.find((status) => status.name === 'lint') === undefined) {
            throw this._createError('Pull request is missing expected status checks. Check the pull request for pending workflows');
        }
        if (combinedStatus === PullRequestStatus.PENDING) {
            throw this._createError('Pull request has pending status checks.');
        }
        if (combinedStatus === PullRequestStatus.FAILING) {
            throw this._createError('Pull request has failing status checks.');
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXJ0LXBhc3NpbmctY2kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9uZy1kZXYvcHIvY29tbW9uL3ZhbGlkYXRpb24vYXNzZXJ0LXBhc3NpbmctY2kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUNMLHlCQUF5QixFQUV6QixpQkFBaUIsR0FDbEIsTUFBTSwwQkFBMEIsQ0FBQztBQUNsQyxPQUFPLEVBQUMsMkJBQTJCLEVBQUUscUJBQXFCLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUUxRixnRUFBZ0U7QUFDaEUsdUZBQXVGO0FBQ3ZGLE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHLDJCQUEyQixDQUM1RCxFQUFDLElBQUksRUFBRSxpQkFBaUIsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUMsRUFDbEQsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUNqQixDQUFDO0FBRUYsTUFBTSxVQUFXLFNBQVEscUJBQXFCO0lBQzVDLE1BQU0sQ0FBQyxXQUFrQztRQUN2QyxNQUFNLEVBQUMsY0FBYyxFQUFFLFFBQVEsRUFBQyxHQUFHLHlCQUF5QixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTFFLDRFQUE0RTtRQUM1RSw2RkFBNkY7UUFDN0YsMkZBQTJGO1FBQzNGLDhGQUE4RjtRQUM5RixJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDcEUsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUNyQiw4RkFBOEYsQ0FDL0YsQ0FBQztRQUNKLENBQUM7UUFDRCxJQUFJLGNBQWMsS0FBSyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNqRCxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMseUNBQXlDLENBQUMsQ0FBQztRQUNyRSxDQUFDO1FBQ0QsSUFBSSxjQUFjLEtBQUssaUJBQWlCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDakQsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLHlDQUF5QyxDQUFDLENBQUM7UUFDckUsQ0FBQztJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBnZXRTdGF0dXNlc0ZvclB1bGxSZXF1ZXN0LFxuICBQdWxsUmVxdWVzdEZyb21HaXRodWIsXG4gIFB1bGxSZXF1ZXN0U3RhdHVzLFxufSBmcm9tICcuLi9mZXRjaC1wdWxsLXJlcXVlc3QuanMnO1xuaW1wb3J0IHtjcmVhdGVQdWxsUmVxdWVzdFZhbGlkYXRpb24sIFB1bGxSZXF1ZXN0VmFsaWRhdGlvbn0gZnJvbSAnLi92YWxpZGF0aW9uLWNvbmZpZy5qcyc7XG5cbi8qKiBBc3NlcnQgdGhlIHB1bGwgcmVxdWVzdCBoYXMgYSBwYXNzaW5nIGNvbWJpbmVkIENJIHN0YXR1cy4gKi9cbi8vIFRPRE86IHVwZGF0ZSB0eXBpbmdzIHRvIG1ha2Ugc3VyZSBwb3J0YWJpbGl0eSBpcyBwcm9wZXJseSBoYW5kbGVkIGZvciB3aW5kb3dzIGJ1aWxkLlxuZXhwb3J0IGNvbnN0IHBhc3NpbmdDaVZhbGlkYXRpb24gPSBjcmVhdGVQdWxsUmVxdWVzdFZhbGlkYXRpb24oXG4gIHtuYW1lOiAnYXNzZXJ0UGFzc2luZ0NpJywgY2FuQmVGb3JjZUlnbm9yZWQ6IHRydWV9LFxuICAoKSA9PiBWYWxpZGF0aW9uLFxuKTtcblxuY2xhc3MgVmFsaWRhdGlvbiBleHRlbmRzIFB1bGxSZXF1ZXN0VmFsaWRhdGlvbiB7XG4gIGFzc2VydChwdWxsUmVxdWVzdDogUHVsbFJlcXVlc3RGcm9tR2l0aHViKSB7XG4gICAgY29uc3Qge2NvbWJpbmVkU3RhdHVzLCBzdGF0dXNlc30gPSBnZXRTdGF0dXNlc0ZvclB1bGxSZXF1ZXN0KHB1bGxSZXF1ZXN0KTtcblxuICAgIC8vIFRPRE8oam9zZXBocGVycm90dCk6IEZpbmQgYSB3YXkgdG8gbm90IG5lZWQgdG8gZG8gdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAvLyBCZWNhdXNlIGl0cyBub3QgcG9zc2libGUgdG8gZGV0ZXJtaW5lIGlmIHdvcmtmbG93IGlzIHBlbmRpbmcgYXBwcm92YWwgb3IgaWYgYWxsIGNoZWNrcyBhbmRcbiAgICAvLyBzdGF0dXNlcyBoYXZlIHJ1biwgd2UgdXNlIHRoZSBgQ0kgLyBsaW50IChwdWxsX3JlcXVlc3QpYCBhcyBhIG1hcmtlciBmb3IgaWYgdGhlIGV4cGVjdGVkXG4gICAgLy8gY2hlY2tzIGhhdmUgcnVuIGFscmVhZHkuICBJZiB0aGV5IGhhdmUgbm90IHlldCBydW4sIHdlIG1hcmsgdGhlIGNvbWJpbmVkIHN0YXR1cyBhcyBtaXNzaW5nLlxuICAgIGlmIChzdGF0dXNlcy5maW5kKChzdGF0dXMpID0+IHN0YXR1cy5uYW1lID09PSAnbGludCcpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKFxuICAgICAgICAnUHVsbCByZXF1ZXN0IGlzIG1pc3NpbmcgZXhwZWN0ZWQgc3RhdHVzIGNoZWNrcy4gQ2hlY2sgdGhlIHB1bGwgcmVxdWVzdCBmb3IgcGVuZGluZyB3b3JrZmxvd3MnLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbWJpbmVkU3RhdHVzID09PSBQdWxsUmVxdWVzdFN0YXR1cy5QRU5ESU5HKSB7XG4gICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcignUHVsbCByZXF1ZXN0IGhhcyBwZW5kaW5nIHN0YXR1cyBjaGVja3MuJyk7XG4gICAgfVxuICAgIGlmIChjb21iaW5lZFN0YXR1cyA9PT0gUHVsbFJlcXVlc3RTdGF0dXMuRkFJTElORykge1xuICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoJ1B1bGwgcmVxdWVzdCBoYXMgZmFpbGluZyBzdGF0dXMgY2hlY2tzLicpO1xuICAgIH1cbiAgfVxufVxuIl19