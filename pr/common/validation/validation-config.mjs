/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { PullRequestValidationFailure } from './validation-failure.js';
/**
 * Pull request validation configuration controlling which assertions
 * should run or not. This enables the forcibly non-fatal ignore feature.
 */
const defaultConfig = {
    assertPending: true,
    assertMergeReady: true,
    assertSignedCla: true,
    assertChangesAllowForTargetLabel: true,
    assertPassingCi: true,
    assertCompletedReviews: true,
    assertEnforcedStatuses: true,
    assertMinimumReviews: true,
    assertIsolatedSeparateFiles: false,
    assertEnforceTested: false,
};
export function createPullRequestValidationConfig(config) {
    return { ...defaultConfig, ...config };
}
/**
 * Base class for pull request validations, providing helpers for the validation errors,
 * and a consistent interface for checking the activation state of validations
 */
export class PullRequestValidation {
    constructor(name, _createError) {
        this.name = name;
        this._createError = _createError;
    }
}
/** Creates a pull request validation from a configuration and implementation class. */
export function createPullRequestValidation({ name, canBeForceIgnored }, getValidationCtor) {
    return {
        async run(validationConfig, ...args) {
            if (validationConfig[name]) {
                const validation = new (getValidationCtor())(name, (message) => new PullRequestValidationFailure(message, name, canBeForceIgnored));
                try {
                    await validation.assert(...args);
                }
                catch (e) {
                    if (e instanceof PullRequestValidationFailure) {
                        return e;
                    }
                    throw e;
                }
            }
            return null;
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbi1jb25maWcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9uZy1kZXYvcHIvY29tbW9uL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBR0gsT0FBTyxFQUFDLDRCQUE0QixFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFFckU7OztHQUdHO0FBQ0gsTUFBTSxhQUFhLEdBQWdDO0lBQ2pELGFBQWEsRUFBRSxJQUFJO0lBQ25CLGdCQUFnQixFQUFFLElBQUk7SUFDdEIsZUFBZSxFQUFFLElBQUk7SUFDckIsZ0NBQWdDLEVBQUUsSUFBSTtJQUN0QyxlQUFlLEVBQUUsSUFBSTtJQUNyQixzQkFBc0IsRUFBRSxJQUFJO0lBQzVCLHNCQUFzQixFQUFFLElBQUk7SUFDNUIsb0JBQW9CLEVBQUUsSUFBSTtJQUMxQiwyQkFBMkIsRUFBRSxLQUFLO0lBQ2xDLG1CQUFtQixFQUFFLEtBQUs7Q0FDM0IsQ0FBQztBQUVGLE1BQU0sVUFBVSxpQ0FBaUMsQ0FDL0MsTUFBbUM7SUFFbkMsT0FBTyxFQUFDLEdBQUcsYUFBYSxFQUFFLEdBQUcsTUFBTSxFQUFDLENBQUM7QUFDdkMsQ0FBQztBQUtEOzs7R0FHRztBQUNILE1BQU0sT0FBZ0IscUJBQXFCO0lBQ3pDLFlBQ1ksSUFBdUMsRUFDdkMsWUFBZ0Q7UUFEaEQsU0FBSSxHQUFKLElBQUksQ0FBbUM7UUFDdkMsaUJBQVksR0FBWixZQUFZLENBQW9DO0lBQ3pELENBQUM7Q0FJTDtBQUVELHVGQUF1RjtBQUN2RixNQUFNLFVBQVUsMkJBQTJCLENBQ3pDLEVBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUF3RSxFQUNoRyxpQkFBZ0c7SUFFaEcsT0FBTztRQUNMLEtBQUssQ0FBQyxHQUFHLENBQ1AsZ0JBQTZDLEVBQzdDLEdBQUcsSUFBNkI7WUFFaEMsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUMzQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUMxQyxJQUFJLEVBQ0osQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksNEJBQTRCLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRixDQUFDO2dCQUNGLElBQUksQ0FBQztvQkFDSCxNQUFNLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztnQkFDbkMsQ0FBQztnQkFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO29CQUNYLElBQUksQ0FBQyxZQUFZLDRCQUE0QixFQUFFLENBQUM7d0JBQzlDLE9BQU8sQ0FBQyxDQUFDO29CQUNYLENBQUM7b0JBQ0QsTUFBTSxDQUFDLENBQUM7Z0JBQ1YsQ0FBQztZQUNILENBQUM7WUFDRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1B1bGxSZXF1ZXN0VmFsaWRhdGlvbkNvbmZpZ30gZnJvbSAnLi4vLi4vY29uZmlnL2luZGV4LmpzJztcbmltcG9ydCB7UHVsbFJlcXVlc3RWYWxpZGF0aW9uRmFpbHVyZX0gZnJvbSAnLi92YWxpZGF0aW9uLWZhaWx1cmUuanMnO1xuXG4vKipcbiAqIFB1bGwgcmVxdWVzdCB2YWxpZGF0aW9uIGNvbmZpZ3VyYXRpb24gY29udHJvbGxpbmcgd2hpY2ggYXNzZXJ0aW9uc1xuICogc2hvdWxkIHJ1biBvciBub3QuIFRoaXMgZW5hYmxlcyB0aGUgZm9yY2libHkgbm9uLWZhdGFsIGlnbm9yZSBmZWF0dXJlLlxuICovXG5jb25zdCBkZWZhdWx0Q29uZmlnOiBQdWxsUmVxdWVzdFZhbGlkYXRpb25Db25maWcgPSB7XG4gIGFzc2VydFBlbmRpbmc6IHRydWUsXG4gIGFzc2VydE1lcmdlUmVhZHk6IHRydWUsXG4gIGFzc2VydFNpZ25lZENsYTogdHJ1ZSxcbiAgYXNzZXJ0Q2hhbmdlc0FsbG93Rm9yVGFyZ2V0TGFiZWw6IHRydWUsXG4gIGFzc2VydFBhc3NpbmdDaTogdHJ1ZSxcbiAgYXNzZXJ0Q29tcGxldGVkUmV2aWV3czogdHJ1ZSxcbiAgYXNzZXJ0RW5mb3JjZWRTdGF0dXNlczogdHJ1ZSxcbiAgYXNzZXJ0TWluaW11bVJldmlld3M6IHRydWUsXG4gIGFzc2VydElzb2xhdGVkU2VwYXJhdGVGaWxlczogZmFsc2UsXG4gIGFzc2VydEVuZm9yY2VUZXN0ZWQ6IGZhbHNlLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVB1bGxSZXF1ZXN0VmFsaWRhdGlvbkNvbmZpZyhcbiAgY29uZmlnOiBQdWxsUmVxdWVzdFZhbGlkYXRpb25Db25maWcsXG4pOiBQdWxsUmVxdWVzdFZhbGlkYXRpb25Db25maWcge1xuICByZXR1cm4gey4uLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZ307XG59XG5cbi8qKiBUeXBlIGRlc2NyaWJpbmcgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIHZhbGlkYXRpb25zIHRvIGNyZWF0ZSBhIHZhbGlkYXRpb24gZmFpbHVyZS4gKi9cbmV4cG9ydCB0eXBlIFB1bGxSZXF1ZXN0VmFsaWRhdGlvbkVycm9yQ3JlYXRlRm4gPSAobWVzc2FnZTogc3RyaW5nKSA9PiBQdWxsUmVxdWVzdFZhbGlkYXRpb25GYWlsdXJlO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHB1bGwgcmVxdWVzdCB2YWxpZGF0aW9ucywgcHJvdmlkaW5nIGhlbHBlcnMgZm9yIHRoZSB2YWxpZGF0aW9uIGVycm9ycyxcbiAqIGFuZCBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGZvciBjaGVja2luZyB0aGUgYWN0aXZhdGlvbiBzdGF0ZSBvZiB2YWxpZGF0aW9uc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUHVsbFJlcXVlc3RWYWxpZGF0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIG5hbWU6IGtleW9mIFB1bGxSZXF1ZXN0VmFsaWRhdGlvbkNvbmZpZyxcbiAgICBwcm90ZWN0ZWQgX2NyZWF0ZUVycm9yOiBQdWxsUmVxdWVzdFZhbGlkYXRpb25FcnJvckNyZWF0ZUZuLFxuICApIHt9XG5cbiAgLyoqIEFzc2VydGlvbiBmdW5jdGlvbiB0byBiZSBkZWZpbmVkIGZvciB0aGUgc3BlY2lmaWMgdmFsaWRhdG9yLiAqL1xuICBhYnN0cmFjdCBhc3NlcnQoLi4ucGFyYW1ldGVyczogdW5rbm93bltdKTogdm9pZCB8IFByb21pc2U8dm9pZD47XG59XG5cbi8qKiBDcmVhdGVzIGEgcHVsbCByZXF1ZXN0IHZhbGlkYXRpb24gZnJvbSBhIGNvbmZpZ3VyYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIGNsYXNzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVB1bGxSZXF1ZXN0VmFsaWRhdGlvbjxUIGV4dGVuZHMgUHVsbFJlcXVlc3RWYWxpZGF0aW9uPihcbiAge25hbWUsIGNhbkJlRm9yY2VJZ25vcmVkfToge25hbWU6IGtleW9mIFB1bGxSZXF1ZXN0VmFsaWRhdGlvbkNvbmZpZzsgY2FuQmVGb3JjZUlnbm9yZWQ6IGJvb2xlYW59LFxuICBnZXRWYWxpZGF0aW9uQ3RvcjogKCkgPT4gbmV3ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIFB1bGxSZXF1ZXN0VmFsaWRhdGlvbj4pID0+IFQsXG4pIHtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBydW4oXG4gICAgICB2YWxpZGF0aW9uQ29uZmlnOiBQdWxsUmVxdWVzdFZhbGlkYXRpb25Db25maWcsXG4gICAgICAuLi5hcmdzOiBQYXJhbWV0ZXJzPFRbJ2Fzc2VydCddPlxuICAgICk6IFByb21pc2U8UHVsbFJlcXVlc3RWYWxpZGF0aW9uRmFpbHVyZSB8IG51bGw+IHtcbiAgICAgIGlmICh2YWxpZGF0aW9uQ29uZmlnW25hbWVdKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBuZXcgKGdldFZhbGlkYXRpb25DdG9yKCkpKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgKG1lc3NhZ2UpID0+IG5ldyBQdWxsUmVxdWVzdFZhbGlkYXRpb25GYWlsdXJlKG1lc3NhZ2UsIG5hbWUsIGNhbkJlRm9yY2VJZ25vcmVkKSxcbiAgICAgICAgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB2YWxpZGF0aW9uLmFzc2VydCguLi5hcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHVsbFJlcXVlc3RWYWxpZGF0aW9uRmFpbHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gIH07XG59XG4iXX0=