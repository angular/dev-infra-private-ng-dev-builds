{"version":3,"file":"labels.js","sourceRoot":"","sources":["labels.ts"],"names":[],"mappings":"AAQA,OAAO,EAAC,wBAAwB,EAAgB,MAAM,kCAAkC,CAAC;AACzF,OAAO,EAEL,iBAAiB,EACjB,eAAe,GAEhB,MAAM,sCAAsC,CAAC;AAC9C,OAAO,EACL,uBAAuB,EACvB,qBAAqB,GAGtB,MAAM,0BAA0B,CAAC;AAClC,OAAO,EACL,wBAAwB,EACxB,uBAAuB,GAExB,MAAM,mBAAmB,CAAC;AAE3B,OAAO,EAAC,qBAAqB,EAAC,MAAM,iBAAiB,CAAC;AAEtD,OAAO,EAAC,GAAG,EAAC,MAAM,2BAA2B,CAAC;AAC9C,OAAO,EAAC,4BAA4B,EAAoB,MAAM,uBAAuB,CAAC;AACtF,OAAO,EAAC,YAAY,EAAC,MAAM,qBAAqB,CAAC;AAejD,MAAM,CAAC,KAAK,UAAU,2CAA2C,CAC/D,EAAC,MAAM,EAAE,gBAAgB,EAAE,IAAI,EAAE,gBAAgB,EAAsB,EACvE,GAAiB,EACjB,MAIE;IAEF,uBAAuB,CAAC,MAAM,CAAC,CAAC;IAChC,4BAA4B,CAAC,MAAM,CAAC,CAAC;IAErC,MAAM,cAAc,GAAG,iBAAiB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IACxD,MAAM,IAAI,GAAuB;QAC/B,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK;QAC1B,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI;QACxB,cAAc;QACd,GAAG;KACJ,CAAC;IAEF,MAAM,YAAY,GAAwB;QACxC;YACE,KAAK,EAAE,YAAY,CAAC,cAAc,CAAC;YACnC,QAAQ,EAAE,GAAG,EAAE;gBAGb,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;oBAClB,MAAM,IAAI,uBAAuB,CAC/B,sCAAsC,cAAc,+BAA+B;wBACjF,kBAAkB,CACrB,CAAC;gBACJ,CAAC;gBACD,OAAO,CAAC,cAAc,CAAC,CAAC;YAC1B,CAAC;SACF;QACD;YACE,KAAK,EAAE,YAAY,CAAC,cAAc,CAAC;YACnC,QAAQ,EAAE,CAAC,kBAAkB,EAAE,EAAE;gBAK/B,IAAI,kBAAkB,KAAK,gBAAgB,EAAE,UAAU,EAAE,CAAC;oBACxD,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;gBACvC,CAAC;gBAED,OAAO,CAAC,cAAc,CAAC,CAAC;YAC1B,CAAC;SACF;QACD;YACE,KAAK,EAAE,YAAY,CAAC,cAAc,CAAC;YACnC,QAAQ,EAAE,CAAC,kBAAkB,EAAE,EAAE;gBAK/B,IAAI,kBAAkB,KAAK,MAAM,CAAC,UAAU,EAAE,CAAC;oBAC7C,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;gBAC7B,CAAC;gBAED,MAAM,QAAQ,GAAG,CAAC,cAAc,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;gBAGrD,IAAI,gBAAgB,KAAK,IAAI,EAAE,CAAC;oBAC9B,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;gBAC7C,CAAC;gBAKD,IAAI,gBAAgB,KAAK,IAAI,EAAE,CAAC;oBAC9B,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;gBAC7C,CAAC;gBACD,OAAO,QAAQ,CAAC;YAClB,CAAC;SACF;QACD;YACE,KAAK,EAAE,YAAY,CAAC,WAAW,CAAC;YAChC,QAAQ,EAAE,CAAC,kBAAkB,EAAE,EAAE;gBAG/B,IAAI,gBAAgB,KAAK,IAAI,EAAE,CAAC;oBAC9B,MAAM,IAAI,uBAAuB,CAC/B,qDAAqD;wBACnD,wDAAwD,CAC3D,CAAC;gBACJ,CAAC;gBAKD,IAAI,kBAAkB,KAAK,gBAAgB,CAAC,UAAU,EAAE,CAAC;oBACvD,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;gBACvC,CAAC;gBAED,OAAO,CAAC,cAAc,EAAE,gBAAgB,CAAC,UAAU,CAAC,CAAC;YACvD,CAAC;SACF;QACD;YACE,KAAK,EAAE,YAAY,CAAC,gBAAgB,CAAC;YACrC,QAAQ,EAAE,CAAC,kBAAkB,EAAE,EAAE;gBAC/B,IAAI,eAAe,CAAC,kBAAkB,CAAC,IAAI,kBAAkB,KAAK,cAAc,EAAE,CAAC;oBACjF,MAAM,IAAI,wBAAwB,CAChC,mEAAmE,CACpE,CAAC;gBACJ,CAAC;gBACD,OAAO,CAAC,kBAAkB,CAAC,CAAC;YAC9B,CAAC;SACF;QACD;YACE,KAAK,EAAE,YAAY,CAAC,mBAAmB,CAAC;YACxC,QAAQ,EAAE,CAAC,kBAAkB,EAAE,EAAE;gBAC/B,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,EAAE,CAAC;oBACzC,MAAM,IAAI,wBAAwB,CAChC,qEAAqE,CACtE,CAAC;gBACJ,CAAC;gBACD,OAAO,CAAC,kBAAkB,CAAC,CAAC;YAC9B,CAAC;SACF;KACF,CAAC;IAIF,IAAI,CAAC;QACH,wBAAwB,CAAC,MAAM,CAAC,CAAC;QACjC,YAAY,CAAC,IAAI,CAAC;YAKhB,KAAK,EAAE,YAAY,CAAC,YAAY,CAAC;YACjC,QAAQ,EAAE,KAAK,EAAE,kBAAkB,EAAE,EAAE;gBACrC,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,EAAE,CAAC;oBACzC,MAAM,IAAI,wBAAwB,CAChC,gEAAgE;wBAC9D,YAAY,kBAAkB,GAAG,CACpC,CAAC;gBACJ,CAAC;gBACD,IAAI,kBAAkB,KAAK,MAAM,CAAC,UAAU,EAAE,CAAC;oBAC7C,MAAM,IAAI,wBAAwB,CAChC,4DAA4D;wBAC1D,wEAAwE,CAC3E,CAAC;gBACJ,CAAC;gBACD,IAAI,gBAAgB,KAAK,IAAI,IAAI,kBAAkB,KAAK,gBAAgB,CAAC,UAAU,EAAE,CAAC;oBACpF,MAAM,IAAI,wBAAwB,CAChC,+EAA+E;wBAC7E,6EAA6E,CAChF,CAAC;gBACJ,CAAC;gBAED,wBAAwB,CAAC,MAAM,CAAC,CAAC;gBACjC,MAAM,qBAAqB,CAAC,IAAI,EAAE,MAAM,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;gBACtE,OAAO,CAAC,kBAAkB,CAAC,CAAC;YAC9B,CAAC;SACF,CAAC,CAAC;IACL,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACb,IAAI,GAAG,YAAY,qBAAqB,EAAE,CAAC;YACzC,GAAG,CAAC,KAAK,CAAC,oEAAoE,CAAC,CAAC;YAChF,GAAG,CAAC,KAAK,CAAC,qEAAqE,CAAC,CAAC;QACnF,CAAC;aAAM,CAAC;YACN,MAAM,GAAG,CAAC;QACZ,CAAC;IACH,CAAC;IAED,OAAO,YAAY,CAAC;AACtB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertValidReleaseConfig, ReleaseConfig} from '../../../release/config/index.js';\nimport {\n  ActiveReleaseTrains,\n  getNextBranchName,\n  isVersionBranch,\n  ReleaseRepoWithApi,\n} from '../../../release/versioning/index.js';\nimport {\n  assertValidGithubConfig,\n  ConfigValidationError,\n  GithubConfig,\n  NgDevConfig,\n} from '../../../utils/config.js';\nimport {\n  InvalidTargetBranchError,\n  InvalidTargetLabelError,\n  TargetLabelConfig,\n} from './target-label.js';\n\nimport {assertActiveLtsBranch} from './lts-branch.js';\nimport {GithubClient} from '../../../utils/git/github.js';\nimport {Log} from '../../../utils/logging.js';\nimport {assertValidPullRequestConfig, PullRequestConfig} from '../../config/index.js';\nimport {targetLabels} from '../labels/target.js';\n\n/**\n * Gets a list of target labels and their configs. The merge tooling will\n * respect match to the appropriate label config and leverage it for determining\n * into which branches a pull request should merge into.\n *\n * The target label configs are implemented according to the design document which\n * specifies versioning, branching and releasing for the Angular organization:\n * https://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU\n *\n * @param api Instance of a Github client. Used to query for the release train branches.\n * @param config Configuration for the Github remote and release packages. Used to fetch\n *   NPM version data when LTS version branches are validated.\n */\nexport async function getTargetLabelConfigsForActiveReleaseTrains(\n  {latest, releaseCandidate, next, exceptionalMinor}: ActiveReleaseTrains,\n  api: GithubClient,\n  config: NgDevConfig<{\n    github: GithubConfig;\n    pullRequest: PullRequestConfig;\n    release?: ReleaseConfig;\n  }>,\n): Promise<TargetLabelConfig[]> {\n  assertValidGithubConfig(config);\n  assertValidPullRequestConfig(config);\n\n  const nextBranchName = getNextBranchName(config.github);\n  const repo: ReleaseRepoWithApi = {\n    owner: config.github.owner,\n    name: config.github.name,\n    nextBranchName,\n    api,\n  };\n\n  const labelConfigs: TargetLabelConfig[] = [\n    {\n      label: targetLabels['TARGET_MAJOR'],\n      branches: () => {\n        // If `next` is currently not designated to be a major version, we do not\n        // allow merging of PRs with `target: major`.\n        if (!next.isMajor) {\n          throw new InvalidTargetLabelError(\n            `Unable to merge pull request. The \"${nextBranchName}\" branch will be released as ` +\n              'a minor version.',\n          );\n        }\n        return [nextBranchName];\n      },\n    },\n    {\n      label: targetLabels['TARGET_MINOR'],\n      branches: (githubTargetBranch) => {\n        // If there is an exceptional minor in-progress, and a PR specifically sets\n        // its destination to it, along with `target: minor`, then we merge into it.\n        // This allows for an exceptional minor train to receive e.g. features.\n        // See: http://go/angular-exceptional-minor\n        if (githubTargetBranch === exceptionalMinor?.branchName) {\n          return [exceptionalMinor.branchName];\n        }\n\n        return [nextBranchName];\n      },\n    },\n    {\n      label: targetLabels['TARGET_PATCH'],\n      branches: (githubTargetBranch) => {\n        // If a PR is targeting the latest active version-branch through the Github UI,\n        // and is also labeled with `target: patch`, then we merge it directly into the\n        // branch without doing any cherry-picking. This is useful if a PR could not be\n        // applied cleanly, and a separate PR for the patch branch has been created.\n        if (githubTargetBranch === latest.branchName) {\n          return [latest.branchName];\n        }\n        // Otherwise, patch changes are always merged into the next and patch branch.\n        const branches = [nextBranchName, latest.branchName];\n        // Additionally, if there is a release-candidate/feature-freeze release-train\n        // currently active, also merge the PR into that version-branch.\n        if (releaseCandidate !== null) {\n          branches.push(releaseCandidate.branchName);\n        }\n        // If there is an exceptional minor, patch changes should always go into it.\n        // It would be a potential loss of fixes/patches if suddenly the exceptional\n        // minor becomes the new patch- but misses some commits.\n        // More details here: http://go/angular-exceptional-minor.\n        if (exceptionalMinor !== null) {\n          branches.push(exceptionalMinor.branchName);\n        }\n        return branches;\n      },\n    },\n    {\n      label: targetLabels['TARGET_RC'],\n      branches: (githubTargetBranch) => {\n        // The `target: rc` label cannot be applied if there is no active feature-freeze\n        // or release-candidate release train.\n        if (releaseCandidate === null) {\n          throw new InvalidTargetLabelError(\n            `No active feature-freeze/release-candidate branch. ` +\n              `Unable to merge pull request using \"target: rc\" label.`,\n          );\n        }\n        // If the PR is targeting the active release-candidate/feature-freeze version branch\n        // directly through the Github UI and has the `target: rc` label applied, merge it\n        // only into the release candidate branch. This is useful if a PR did not apply cleanly\n        // into the release-candidate/feature-freeze branch, and a separate PR has been created.\n        if (githubTargetBranch === releaseCandidate.branchName) {\n          return [releaseCandidate.branchName];\n        }\n        // Otherwise, merge into the next and active release-candidate/feature-freeze branch.\n        return [nextBranchName, releaseCandidate.branchName];\n      },\n    },\n    {\n      label: targetLabels['TARGET_FEATURE'],\n      branches: (githubTargetBranch) => {\n        if (isVersionBranch(githubTargetBranch) || githubTargetBranch === nextBranchName) {\n          throw new InvalidTargetBranchError(\n            '\"target: feature\" pull requests cannot target a releasable branch',\n          );\n        }\n        return [githubTargetBranch];\n      },\n    },\n    {\n      label: targetLabels['TARGET_AUTOMATION'],\n      branches: (githubTargetBranch) => {\n        if (!isVersionBranch(githubTargetBranch)) {\n          throw new InvalidTargetBranchError(\n            '\"target: automation\" pull requests can only target a release branch',\n          );\n        }\n        return [githubTargetBranch];\n      },\n    },\n  ];\n\n  // LTS branches can only be determined if the release configuration is defined, and must be added\n  // after asserting the configuration contains a release config.\n  try {\n    assertValidReleaseConfig(config);\n    labelConfigs.push({\n      // LTS changes are rare enough that we won't worry about cherry-picking changes into all\n      // active LTS branches for PRs created against any other branch. Instead, PR authors need\n      // to manually create separate PRs for desired LTS branches. Additionally, active LT branches\n      // commonly diverge quickly. This makes cherry-picking not an option for LTS changes.\n      label: targetLabels['TARGET_LTS'],\n      branches: async (githubTargetBranch) => {\n        if (!isVersionBranch(githubTargetBranch)) {\n          throw new InvalidTargetBranchError(\n            `PR cannot be merged as it does not target a long-term support ` +\n              `branch: \"${githubTargetBranch}\"`,\n          );\n        }\n        if (githubTargetBranch === latest.branchName) {\n          throw new InvalidTargetBranchError(\n            `PR cannot be merged with \"target: lts\" into patch branch. ` +\n              `Consider changing the label to \"target: patch\" if this is intentional.`,\n          );\n        }\n        if (releaseCandidate !== null && githubTargetBranch === releaseCandidate.branchName) {\n          throw new InvalidTargetBranchError(\n            `PR cannot be merged with \"target: lts\" into feature-freeze/release-candidate ` +\n              `branch. Consider changing the label to \"target: rc\" if this is intentional.`,\n          );\n        }\n        // Assert that the selected branch is an active LTS branch.\n        assertValidReleaseConfig(config);\n        await assertActiveLtsBranch(repo, config.release, githubTargetBranch);\n        return [githubTargetBranch];\n      },\n    });\n  } catch (err) {\n    if (err instanceof ConfigValidationError) {\n      Log.debug('LTS target label not included in target labels as no valid release');\n      Log.debug('configuration was found to allow the LTS branches to be determined.');\n    } else {\n      throw err;\n    }\n  }\n\n  return labelConfigs;\n}\n"]}