/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import semver from 'semver';
import { computeLtsEndDateOfMajor, fetchProjectNpmPackageInfo, getLtsNpmDistTagOfMajor, getVersionInfoForBranch, } from '../../../release/versioning/index.js';
import { Log, red, yellow } from '../../../utils/logging.js';
import { InvalidTargetBranchError } from './target-label.js';
import { defaultLocale } from '../../../utils/locale.js';
import { Prompt } from '../../../utils/prompt.js';
/**
 * Asserts that the given branch corresponds to an active LTS version-branch that can receive
 * backport fixes. Throws an error if LTS expired or an invalid branch is selected.
 *
 * @param repo Repository containing the given branch. Used for Github API queries.
 * @param releaseConfig Configuration for releases. Used to query NPM about past publishes.
 * @param branchName Branch that is checked to be an active LTS version-branch.
 * */
export async function assertActiveLtsBranch(repo, releaseConfig, branchName) {
    const { version } = await getVersionInfoForBranch(repo, branchName);
    const { 'dist-tags': distTags, time } = await fetchProjectNpmPackageInfo(releaseConfig);
    // LTS versions should be tagged in NPM in the following format: `v{major}-lts`.
    const ltsNpmTag = getLtsNpmDistTagOfMajor(version.major);
    const ltsVersion = semver.parse(distTags[ltsNpmTag]);
    // Ensure that there is an LTS version tagged for the given version-branch major. e.g.
    // if the version branch is `9.2.x` then we want to make sure that there is an LTS
    // version tagged in NPM for `v9`, following the `v{major}-lts` tag convention.
    if (ltsVersion === null) {
        throw new InvalidTargetBranchError(`No LTS version tagged for v${version.major} in NPM.`);
    }
    // Ensure that the correct branch is used for the LTS version. We do not want to merge
    // changes to older minor version branches that do not reflect the current LTS version.
    if (branchName !== `${ltsVersion.major}.${ltsVersion.minor}.x`) {
        throw new InvalidTargetBranchError(`Not using last-minor branch for v${version.major} LTS version. PR ` +
            `should be updated to target: ${ltsVersion.major}.${ltsVersion.minor}.x`);
    }
    const today = new Date();
    const majorReleaseDate = new Date(time[`${version.major}.0.0`]);
    const ltsEndDate = computeLtsEndDateOfMajor(majorReleaseDate);
    // Check if LTS has already expired for the targeted major version. If so, we do not
    // allow the merge as per our LTS guarantees. Can be forcibly overridden if desired.
    // See: https://angular.io/guide/releases#support-policy-and-schedule.
    if (today > ltsEndDate) {
        const ltsEndDateText = ltsEndDate.toLocaleDateString(defaultLocale);
        Log.warn(red(`Long-term support ended for v${version.major} on ${ltsEndDateText}.`));
        Log.warn(yellow(`Merging of pull requests for this major is generally not ` +
            `desired, but can be forcibly ignored.`));
        if (await Prompt.confirm({ message: 'Do you want to forcibly proceed with merging?' })) {
            return;
        }
        throw new InvalidTargetBranchError(`Long-term supported ended for v${version.major} on ${ltsEndDateText}. ` +
            `Pull request cannot be merged into the ${branchName} branch.`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHRzLWJyYW5jaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9wci9jb21tb24vdGFyZ2V0aW5nL2x0cy1icmFuY2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBRzVCLE9BQU8sRUFDTCx3QkFBd0IsRUFDeEIsMEJBQTBCLEVBQzFCLHVCQUF1QixFQUN2Qix1QkFBdUIsR0FFeEIsTUFBTSxzQ0FBc0MsQ0FBQztBQUU5QyxPQUFPLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQUMsd0JBQXdCLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUMzRCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDdkQsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBRWhEOzs7Ozs7O0tBT0s7QUFDTCxNQUFNLENBQUMsS0FBSyxVQUFVLHFCQUFxQixDQUN6QyxJQUF3QixFQUN4QixhQUE0QixFQUM1QixVQUFrQjtJQUVsQixNQUFNLEVBQUMsT0FBTyxFQUFDLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbEUsTUFBTSxFQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFDLEdBQUcsTUFBTSwwQkFBMEIsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUV0RixnRkFBZ0Y7SUFDaEYsTUFBTSxTQUFTLEdBQUcsdUJBQXVCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFFckQsc0ZBQXNGO0lBQ3RGLGtGQUFrRjtJQUNsRiwrRUFBK0U7SUFDL0UsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDeEIsTUFBTSxJQUFJLHdCQUF3QixDQUFDLDhCQUE4QixPQUFPLENBQUMsS0FBSyxVQUFVLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRUQsc0ZBQXNGO0lBQ3RGLHVGQUF1RjtJQUN2RixJQUFJLFVBQVUsS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLElBQUksVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDL0QsTUFBTSxJQUFJLHdCQUF3QixDQUNoQyxvQ0FBb0MsT0FBTyxDQUFDLEtBQUssbUJBQW1CO1lBQ2xFLGdDQUFnQyxVQUFVLENBQUMsS0FBSyxJQUFJLFVBQVUsQ0FBQyxLQUFLLElBQUksQ0FDM0UsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3pCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNoRSxNQUFNLFVBQVUsR0FBRyx3QkFBd0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRTlELG9GQUFvRjtJQUNwRixvRkFBb0Y7SUFDcEYsc0VBQXNFO0lBQ3RFLElBQUksS0FBSyxHQUFHLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNwRSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQ0FBZ0MsT0FBTyxDQUFDLEtBQUssT0FBTyxjQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckYsR0FBRyxDQUFDLElBQUksQ0FDTixNQUFNLENBQ0osMkRBQTJEO1lBQ3pELHVDQUF1QyxDQUMxQyxDQUNGLENBQUM7UUFDRixJQUFJLE1BQU0sTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFDLE9BQU8sRUFBRSwrQ0FBK0MsRUFBQyxDQUFDLEVBQUUsQ0FBQztZQUNyRixPQUFPO1FBQ1QsQ0FBQztRQUNELE1BQU0sSUFBSSx3QkFBd0IsQ0FDaEMsa0NBQWtDLE9BQU8sQ0FBQyxLQUFLLE9BQU8sY0FBYyxJQUFJO1lBQ3RFLDBDQUEwQyxVQUFVLFVBQVUsQ0FDakUsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuaW1wb3J0IHtSZWxlYXNlQ29uZmlnfSBmcm9tICcuLi8uLi8uLi9yZWxlYXNlL2NvbmZpZy9pbmRleC5qcyc7XG5pbXBvcnQge1xuICBjb21wdXRlTHRzRW5kRGF0ZU9mTWFqb3IsXG4gIGZldGNoUHJvamVjdE5wbVBhY2thZ2VJbmZvLFxuICBnZXRMdHNOcG1EaXN0VGFnT2ZNYWpvcixcbiAgZ2V0VmVyc2lvbkluZm9Gb3JCcmFuY2gsXG4gIFJlbGVhc2VSZXBvV2l0aEFwaSxcbn0gZnJvbSAnLi4vLi4vLi4vcmVsZWFzZS92ZXJzaW9uaW5nL2luZGV4LmpzJztcblxuaW1wb3J0IHtMb2csIHJlZCwgeWVsbG93fSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nLmpzJztcbmltcG9ydCB7SW52YWxpZFRhcmdldEJyYW5jaEVycm9yfSBmcm9tICcuL3RhcmdldC1sYWJlbC5qcyc7XG5pbXBvcnQge2RlZmF1bHRMb2NhbGV9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvY2FsZS5qcyc7XG5pbXBvcnQge1Byb21wdH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcHJvbXB0LmpzJztcblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGJyYW5jaCBjb3JyZXNwb25kcyB0byBhbiBhY3RpdmUgTFRTIHZlcnNpb24tYnJhbmNoIHRoYXQgY2FuIHJlY2VpdmVcbiAqIGJhY2twb3J0IGZpeGVzLiBUaHJvd3MgYW4gZXJyb3IgaWYgTFRTIGV4cGlyZWQgb3IgYW4gaW52YWxpZCBicmFuY2ggaXMgc2VsZWN0ZWQuXG4gKlxuICogQHBhcmFtIHJlcG8gUmVwb3NpdG9yeSBjb250YWluaW5nIHRoZSBnaXZlbiBicmFuY2guIFVzZWQgZm9yIEdpdGh1YiBBUEkgcXVlcmllcy5cbiAqIEBwYXJhbSByZWxlYXNlQ29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHJlbGVhc2VzLiBVc2VkIHRvIHF1ZXJ5IE5QTSBhYm91dCBwYXN0IHB1Ymxpc2hlcy5cbiAqIEBwYXJhbSBicmFuY2hOYW1lIEJyYW5jaCB0aGF0IGlzIGNoZWNrZWQgdG8gYmUgYW4gYWN0aXZlIExUUyB2ZXJzaW9uLWJyYW5jaC5cbiAqICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXNzZXJ0QWN0aXZlTHRzQnJhbmNoKFxuICByZXBvOiBSZWxlYXNlUmVwb1dpdGhBcGksXG4gIHJlbGVhc2VDb25maWc6IFJlbGVhc2VDb25maWcsXG4gIGJyYW5jaE5hbWU6IHN0cmluZyxcbikge1xuICBjb25zdCB7dmVyc2lvbn0gPSBhd2FpdCBnZXRWZXJzaW9uSW5mb0ZvckJyYW5jaChyZXBvLCBicmFuY2hOYW1lKTtcbiAgY29uc3QgeydkaXN0LXRhZ3MnOiBkaXN0VGFncywgdGltZX0gPSBhd2FpdCBmZXRjaFByb2plY3ROcG1QYWNrYWdlSW5mbyhyZWxlYXNlQ29uZmlnKTtcblxuICAvLyBMVFMgdmVyc2lvbnMgc2hvdWxkIGJlIHRhZ2dlZCBpbiBOUE0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGB2e21ham9yfS1sdHNgLlxuICBjb25zdCBsdHNOcG1UYWcgPSBnZXRMdHNOcG1EaXN0VGFnT2ZNYWpvcih2ZXJzaW9uLm1ham9yKTtcbiAgY29uc3QgbHRzVmVyc2lvbiA9IHNlbXZlci5wYXJzZShkaXN0VGFnc1tsdHNOcG1UYWddKTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhbiBMVFMgdmVyc2lvbiB0YWdnZWQgZm9yIHRoZSBnaXZlbiB2ZXJzaW9uLWJyYW5jaCBtYWpvci4gZS5nLlxuICAvLyBpZiB0aGUgdmVyc2lvbiBicmFuY2ggaXMgYDkuMi54YCB0aGVuIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlcmUgaXMgYW4gTFRTXG4gIC8vIHZlcnNpb24gdGFnZ2VkIGluIE5QTSBmb3IgYHY5YCwgZm9sbG93aW5nIHRoZSBgdnttYWpvcn0tbHRzYCB0YWcgY29udmVudGlvbi5cbiAgaWYgKGx0c1ZlcnNpb24gPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldEJyYW5jaEVycm9yKGBObyBMVFMgdmVyc2lvbiB0YWdnZWQgZm9yIHYke3ZlcnNpb24ubWFqb3J9IGluIE5QTS5gKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBjb3JyZWN0IGJyYW5jaCBpcyB1c2VkIGZvciB0aGUgTFRTIHZlcnNpb24uIFdlIGRvIG5vdCB3YW50IHRvIG1lcmdlXG4gIC8vIGNoYW5nZXMgdG8gb2xkZXIgbWlub3IgdmVyc2lvbiBicmFuY2hlcyB0aGF0IGRvIG5vdCByZWZsZWN0IHRoZSBjdXJyZW50IExUUyB2ZXJzaW9uLlxuICBpZiAoYnJhbmNoTmFtZSAhPT0gYCR7bHRzVmVyc2lvbi5tYWpvcn0uJHtsdHNWZXJzaW9uLm1pbm9yfS54YCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVGFyZ2V0QnJhbmNoRXJyb3IoXG4gICAgICBgTm90IHVzaW5nIGxhc3QtbWlub3IgYnJhbmNoIGZvciB2JHt2ZXJzaW9uLm1ham9yfSBMVFMgdmVyc2lvbi4gUFIgYCArXG4gICAgICAgIGBzaG91bGQgYmUgdXBkYXRlZCB0byB0YXJnZXQ6ICR7bHRzVmVyc2lvbi5tYWpvcn0uJHtsdHNWZXJzaW9uLm1pbm9yfS54YCxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBtYWpvclJlbGVhc2VEYXRlID0gbmV3IERhdGUodGltZVtgJHt2ZXJzaW9uLm1ham9yfS4wLjBgXSk7XG4gIGNvbnN0IGx0c0VuZERhdGUgPSBjb21wdXRlTHRzRW5kRGF0ZU9mTWFqb3IobWFqb3JSZWxlYXNlRGF0ZSk7XG5cbiAgLy8gQ2hlY2sgaWYgTFRTIGhhcyBhbHJlYWR5IGV4cGlyZWQgZm9yIHRoZSB0YXJnZXRlZCBtYWpvciB2ZXJzaW9uLiBJZiBzbywgd2UgZG8gbm90XG4gIC8vIGFsbG93IHRoZSBtZXJnZSBhcyBwZXIgb3VyIExUUyBndWFyYW50ZWVzLiBDYW4gYmUgZm9yY2libHkgb3ZlcnJpZGRlbiBpZiBkZXNpcmVkLlxuICAvLyBTZWU6IGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9yZWxlYXNlcyNzdXBwb3J0LXBvbGljeS1hbmQtc2NoZWR1bGUuXG4gIGlmICh0b2RheSA+IGx0c0VuZERhdGUpIHtcbiAgICBjb25zdCBsdHNFbmREYXRlVGV4dCA9IGx0c0VuZERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKGRlZmF1bHRMb2NhbGUpO1xuICAgIExvZy53YXJuKHJlZChgTG9uZy10ZXJtIHN1cHBvcnQgZW5kZWQgZm9yIHYke3ZlcnNpb24ubWFqb3J9IG9uICR7bHRzRW5kRGF0ZVRleHR9LmApKTtcbiAgICBMb2cud2FybihcbiAgICAgIHllbGxvdyhcbiAgICAgICAgYE1lcmdpbmcgb2YgcHVsbCByZXF1ZXN0cyBmb3IgdGhpcyBtYWpvciBpcyBnZW5lcmFsbHkgbm90IGAgK1xuICAgICAgICAgIGBkZXNpcmVkLCBidXQgY2FuIGJlIGZvcmNpYmx5IGlnbm9yZWQuYCxcbiAgICAgICksXG4gICAgKTtcbiAgICBpZiAoYXdhaXQgUHJvbXB0LmNvbmZpcm0oe21lc3NhZ2U6ICdEbyB5b3Ugd2FudCB0byBmb3JjaWJseSBwcm9jZWVkIHdpdGggbWVyZ2luZz8nfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEludmFsaWRUYXJnZXRCcmFuY2hFcnJvcihcbiAgICAgIGBMb25nLXRlcm0gc3VwcG9ydGVkIGVuZGVkIGZvciB2JHt2ZXJzaW9uLm1ham9yfSBvbiAke2x0c0VuZERhdGVUZXh0fS4gYCArXG4gICAgICAgIGBQdWxsIHJlcXVlc3QgY2Fubm90IGJlIG1lcmdlZCBpbnRvIHRoZSAke2JyYW5jaE5hbWV9IGJyYW5jaC5gLFxuICAgICk7XG4gIH1cbn1cbiJdfQ==