/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import semver from 'semver';
import { computeLtsEndDateOfMajor, fetchProjectNpmPackageInfo, getLtsNpmDistTagOfMajor, getVersionInfoForBranch, } from '../../../release/versioning/index.js';
import { Prompt } from '../../../utils/prompt.js';
import { Log, red, yellow } from '../../../utils/logging.js';
import { InvalidTargetBranchError } from './target-label.js';
import { defaultLocale } from '../../../utils/locale.js';
/**
 * Asserts that the given branch corresponds to an active LTS version-branch that can receive
 * backport fixes. Throws an error if LTS expired or an invalid branch is selected.
 *
 * @param repo Repository containing the given branch. Used for Github API queries.
 * @param releaseConfig Configuration for releases. Used to query NPM about past publishes.
 * @param branchName Branch that is checked to be an active LTS version-branch.
 * */
export async function assertActiveLtsBranch(repo, releaseConfig, branchName) {
    const { version } = await getVersionInfoForBranch(repo, branchName);
    const { 'dist-tags': distTags, time } = await fetchProjectNpmPackageInfo(releaseConfig);
    // LTS versions should be tagged in NPM in the following format: `v{major}-lts`.
    const ltsNpmTag = getLtsNpmDistTagOfMajor(version.major);
    const ltsVersion = semver.parse(distTags[ltsNpmTag]);
    // Ensure that there is an LTS version tagged for the given version-branch major. e.g.
    // if the version branch is `9.2.x` then we want to make sure that there is an LTS
    // version tagged in NPM for `v9`, following the `v{major}-lts` tag convention.
    if (ltsVersion === null) {
        throw new InvalidTargetBranchError(`No LTS version tagged for v${version.major} in NPM.`);
    }
    // Ensure that the correct branch is used for the LTS version. We do not want to merge
    // changes to older minor version branches that do not reflect the current LTS version.
    if (branchName !== `${ltsVersion.major}.${ltsVersion.minor}.x`) {
        throw new InvalidTargetBranchError(`Not using last-minor branch for v${version.major} LTS version. PR ` +
            `should be updated to target: ${ltsVersion.major}.${ltsVersion.minor}.x`);
    }
    const today = new Date();
    const majorReleaseDate = new Date(time[`${version.major}.0.0`]);
    const ltsEndDate = computeLtsEndDateOfMajor(majorReleaseDate);
    // Check if LTS has already expired for the targeted major version. If so, we do not
    // allow the merge as per our LTS guarantees. Can be forcibly overridden if desired.
    // See: https://angular.io/guide/releases#support-policy-and-schedule.
    if (today > ltsEndDate) {
        const ltsEndDateText = ltsEndDate.toLocaleDateString(defaultLocale);
        Log.warn(red(`Long-term support ended for v${version.major} on ${ltsEndDateText}.`));
        Log.warn(yellow(`Merging of pull requests for this major is generally not ` +
            `desired, but can be forcibly ignored.`));
        if (await Prompt.confirm('Do you want to forcibly proceed with merging?')) {
            return;
        }
        throw new InvalidTargetBranchError(`Long-term supported ended for v${version.major} on ${ltsEndDateText}. ` +
            `Pull request cannot be merged into the ${branchName} branch.`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHRzLWJyYW5jaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9wci9jb21tb24vdGFyZ2V0aW5nL2x0cy1icmFuY2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBRzVCLE9BQU8sRUFDTCx3QkFBd0IsRUFDeEIsMEJBQTBCLEVBQzFCLHVCQUF1QixFQUN2Qix1QkFBdUIsR0FFeEIsTUFBTSxzQ0FBc0MsQ0FBQztBQUM5QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFFaEQsT0FBTyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDM0QsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDM0QsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBRXZEOzs7Ozs7O0tBT0s7QUFDTCxNQUFNLENBQUMsS0FBSyxVQUFVLHFCQUFxQixDQUN6QyxJQUF3QixFQUN4QixhQUE0QixFQUM1QixVQUFrQjtJQUVsQixNQUFNLEVBQUMsT0FBTyxFQUFDLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbEUsTUFBTSxFQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFDLEdBQUcsTUFBTSwwQkFBMEIsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUV0RixnRkFBZ0Y7SUFDaEYsTUFBTSxTQUFTLEdBQUcsdUJBQXVCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFFckQsc0ZBQXNGO0lBQ3RGLGtGQUFrRjtJQUNsRiwrRUFBK0U7SUFDL0UsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDeEIsTUFBTSxJQUFJLHdCQUF3QixDQUFDLDhCQUE4QixPQUFPLENBQUMsS0FBSyxVQUFVLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRUQsc0ZBQXNGO0lBQ3RGLHVGQUF1RjtJQUN2RixJQUFJLFVBQVUsS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLElBQUksVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDL0QsTUFBTSxJQUFJLHdCQUF3QixDQUNoQyxvQ0FBb0MsT0FBTyxDQUFDLEtBQUssbUJBQW1CO1lBQ2xFLGdDQUFnQyxVQUFVLENBQUMsS0FBSyxJQUFJLFVBQVUsQ0FBQyxLQUFLLElBQUksQ0FDM0UsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3pCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNoRSxNQUFNLFVBQVUsR0FBRyx3QkFBd0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRTlELG9GQUFvRjtJQUNwRixvRkFBb0Y7SUFDcEYsc0VBQXNFO0lBQ3RFLElBQUksS0FBSyxHQUFHLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNwRSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQ0FBZ0MsT0FBTyxDQUFDLEtBQUssT0FBTyxjQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckYsR0FBRyxDQUFDLElBQUksQ0FDTixNQUFNLENBQ0osMkRBQTJEO1lBQ3pELHVDQUF1QyxDQUMxQyxDQUNGLENBQUM7UUFDRixJQUFJLE1BQU0sTUFBTSxDQUFDLE9BQU8sQ0FBQywrQ0FBK0MsQ0FBQyxFQUFFLENBQUM7WUFDMUUsT0FBTztRQUNULENBQUM7UUFDRCxNQUFNLElBQUksd0JBQXdCLENBQ2hDLGtDQUFrQyxPQUFPLENBQUMsS0FBSyxPQUFPLGNBQWMsSUFBSTtZQUN0RSwwQ0FBMEMsVUFBVSxVQUFVLENBQ2pFLENBQUM7SUFDSixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7UmVsZWFzZUNvbmZpZ30gZnJvbSAnLi4vLi4vLi4vcmVsZWFzZS9jb25maWcvaW5kZXguanMnO1xuaW1wb3J0IHtcbiAgY29tcHV0ZUx0c0VuZERhdGVPZk1ham9yLFxuICBmZXRjaFByb2plY3ROcG1QYWNrYWdlSW5mbyxcbiAgZ2V0THRzTnBtRGlzdFRhZ09mTWFqb3IsXG4gIGdldFZlcnNpb25JbmZvRm9yQnJhbmNoLFxuICBSZWxlYXNlUmVwb1dpdGhBcGksXG59IGZyb20gJy4uLy4uLy4uL3JlbGVhc2UvdmVyc2lvbmluZy9pbmRleC5qcyc7XG5pbXBvcnQge1Byb21wdH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcHJvbXB0LmpzJztcblxuaW1wb3J0IHtMb2csIHJlZCwgeWVsbG93fSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nLmpzJztcbmltcG9ydCB7SW52YWxpZFRhcmdldEJyYW5jaEVycm9yfSBmcm9tICcuL3RhcmdldC1sYWJlbC5qcyc7XG5pbXBvcnQge2RlZmF1bHRMb2NhbGV9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvY2FsZS5qcyc7XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBicmFuY2ggY29ycmVzcG9uZHMgdG8gYW4gYWN0aXZlIExUUyB2ZXJzaW9uLWJyYW5jaCB0aGF0IGNhbiByZWNlaXZlXG4gKiBiYWNrcG9ydCBmaXhlcy4gVGhyb3dzIGFuIGVycm9yIGlmIExUUyBleHBpcmVkIG9yIGFuIGludmFsaWQgYnJhbmNoIGlzIHNlbGVjdGVkLlxuICpcbiAqIEBwYXJhbSByZXBvIFJlcG9zaXRvcnkgY29udGFpbmluZyB0aGUgZ2l2ZW4gYnJhbmNoLiBVc2VkIGZvciBHaXRodWIgQVBJIHF1ZXJpZXMuXG4gKiBAcGFyYW0gcmVsZWFzZUNvbmZpZyBDb25maWd1cmF0aW9uIGZvciByZWxlYXNlcy4gVXNlZCB0byBxdWVyeSBOUE0gYWJvdXQgcGFzdCBwdWJsaXNoZXMuXG4gKiBAcGFyYW0gYnJhbmNoTmFtZSBCcmFuY2ggdGhhdCBpcyBjaGVja2VkIHRvIGJlIGFuIGFjdGl2ZSBMVFMgdmVyc2lvbi1icmFuY2guXG4gKiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzc2VydEFjdGl2ZUx0c0JyYW5jaChcbiAgcmVwbzogUmVsZWFzZVJlcG9XaXRoQXBpLFxuICByZWxlYXNlQ29uZmlnOiBSZWxlYXNlQ29uZmlnLFxuICBicmFuY2hOYW1lOiBzdHJpbmcsXG4pIHtcbiAgY29uc3Qge3ZlcnNpb259ID0gYXdhaXQgZ2V0VmVyc2lvbkluZm9Gb3JCcmFuY2gocmVwbywgYnJhbmNoTmFtZSk7XG4gIGNvbnN0IHsnZGlzdC10YWdzJzogZGlzdFRhZ3MsIHRpbWV9ID0gYXdhaXQgZmV0Y2hQcm9qZWN0TnBtUGFja2FnZUluZm8ocmVsZWFzZUNvbmZpZyk7XG5cbiAgLy8gTFRTIHZlcnNpb25zIHNob3VsZCBiZSB0YWdnZWQgaW4gTlBNIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBgdnttYWpvcn0tbHRzYC5cbiAgY29uc3QgbHRzTnBtVGFnID0gZ2V0THRzTnBtRGlzdFRhZ09mTWFqb3IodmVyc2lvbi5tYWpvcik7XG4gIGNvbnN0IGx0c1ZlcnNpb24gPSBzZW12ZXIucGFyc2UoZGlzdFRhZ3NbbHRzTnBtVGFnXSk7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYW4gTFRTIHZlcnNpb24gdGFnZ2VkIGZvciB0aGUgZ2l2ZW4gdmVyc2lvbi1icmFuY2ggbWFqb3IuIGUuZy5cbiAgLy8gaWYgdGhlIHZlcnNpb24gYnJhbmNoIGlzIGA5LjIueGAgdGhlbiB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZXJlIGlzIGFuIExUU1xuICAvLyB2ZXJzaW9uIHRhZ2dlZCBpbiBOUE0gZm9yIGB2OWAsIGZvbGxvd2luZyB0aGUgYHZ7bWFqb3J9LWx0c2AgdGFnIGNvbnZlbnRpb24uXG4gIGlmIChsdHNWZXJzaW9uID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUYXJnZXRCcmFuY2hFcnJvcihgTm8gTFRTIHZlcnNpb24gdGFnZ2VkIGZvciB2JHt2ZXJzaW9uLm1ham9yfSBpbiBOUE0uYCk7XG4gIH1cblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgY29ycmVjdCBicmFuY2ggaXMgdXNlZCBmb3IgdGhlIExUUyB2ZXJzaW9uLiBXZSBkbyBub3Qgd2FudCB0byBtZXJnZVxuICAvLyBjaGFuZ2VzIHRvIG9sZGVyIG1pbm9yIHZlcnNpb24gYnJhbmNoZXMgdGhhdCBkbyBub3QgcmVmbGVjdCB0aGUgY3VycmVudCBMVFMgdmVyc2lvbi5cbiAgaWYgKGJyYW5jaE5hbWUgIT09IGAke2x0c1ZlcnNpb24ubWFqb3J9LiR7bHRzVmVyc2lvbi5taW5vcn0ueGApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldEJyYW5jaEVycm9yKFxuICAgICAgYE5vdCB1c2luZyBsYXN0LW1pbm9yIGJyYW5jaCBmb3IgdiR7dmVyc2lvbi5tYWpvcn0gTFRTIHZlcnNpb24uIFBSIGAgK1xuICAgICAgICBgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdGFyZ2V0OiAke2x0c1ZlcnNpb24ubWFqb3J9LiR7bHRzVmVyc2lvbi5taW5vcn0ueGAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgbWFqb3JSZWxlYXNlRGF0ZSA9IG5ldyBEYXRlKHRpbWVbYCR7dmVyc2lvbi5tYWpvcn0uMC4wYF0pO1xuICBjb25zdCBsdHNFbmREYXRlID0gY29tcHV0ZUx0c0VuZERhdGVPZk1ham9yKG1ham9yUmVsZWFzZURhdGUpO1xuXG4gIC8vIENoZWNrIGlmIExUUyBoYXMgYWxyZWFkeSBleHBpcmVkIGZvciB0aGUgdGFyZ2V0ZWQgbWFqb3IgdmVyc2lvbi4gSWYgc28sIHdlIGRvIG5vdFxuICAvLyBhbGxvdyB0aGUgbWVyZ2UgYXMgcGVyIG91ciBMVFMgZ3VhcmFudGVlcy4gQ2FuIGJlIGZvcmNpYmx5IG92ZXJyaWRkZW4gaWYgZGVzaXJlZC5cbiAgLy8gU2VlOiBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvcmVsZWFzZXMjc3VwcG9ydC1wb2xpY3ktYW5kLXNjaGVkdWxlLlxuICBpZiAodG9kYXkgPiBsdHNFbmREYXRlKSB7XG4gICAgY29uc3QgbHRzRW5kRGF0ZVRleHQgPSBsdHNFbmREYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyhkZWZhdWx0TG9jYWxlKTtcbiAgICBMb2cud2FybihyZWQoYExvbmctdGVybSBzdXBwb3J0IGVuZGVkIGZvciB2JHt2ZXJzaW9uLm1ham9yfSBvbiAke2x0c0VuZERhdGVUZXh0fS5gKSk7XG4gICAgTG9nLndhcm4oXG4gICAgICB5ZWxsb3coXG4gICAgICAgIGBNZXJnaW5nIG9mIHB1bGwgcmVxdWVzdHMgZm9yIHRoaXMgbWFqb3IgaXMgZ2VuZXJhbGx5IG5vdCBgICtcbiAgICAgICAgICBgZGVzaXJlZCwgYnV0IGNhbiBiZSBmb3JjaWJseSBpZ25vcmVkLmAsXG4gICAgICApLFxuICAgICk7XG4gICAgaWYgKGF3YWl0IFByb21wdC5jb25maXJtKCdEbyB5b3Ugd2FudCB0byBmb3JjaWJseSBwcm9jZWVkIHdpdGggbWVyZ2luZz8nKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldEJyYW5jaEVycm9yKFxuICAgICAgYExvbmctdGVybSBzdXBwb3J0ZWQgZW5kZWQgZm9yIHYke3ZlcnNpb24ubWFqb3J9IG9uICR7bHRzRW5kRGF0ZVRleHR9LiBgICtcbiAgICAgICAgYFB1bGwgcmVxdWVzdCBjYW5ub3QgYmUgbWVyZ2VkIGludG8gdGhlICR7YnJhbmNoTmFtZX0gYnJhbmNoLmAsXG4gICAgKTtcbiAgfVxufVxuIl19