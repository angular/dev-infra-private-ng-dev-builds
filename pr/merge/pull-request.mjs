/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { getTargetBranchesAndLabelForPullRequest, } from '../common/targeting/target-label.js';
import { fetchPullRequestFromGithub } from '../common/fetch-pull-request.js';
import { FatalMergeToolError } from './failures.js';
import { ActiveReleaseTrains } from '../../release/versioning/active-release-trains.js';
import { assertValidPullRequest } from '../common/validation/validate-pull-request.js';
import { TEMP_PR_HEAD_BRANCH } from './strategies/strategy.js';
import { mergeLabels } from '../common/labels/merge.js';
import { targetLabels } from '../common/labels/target.js';
/**
 * Loads and validates the specified pull request against the given configuration.
 * If the pull requests fails, a pull request failure is returned.
 *
 * @throws {FatalMergeToolError} A fatal error might be thrown when e.g. the pull request
 *   does not exist upstream.
 * @throws {InvalidTargetLabelError} Error thrown if an invalid target label is applied.
 * @throws {InvalidTargetBranchError} Error thrown if an invalid GitHub PR destination branch
 *   is selected.
 */
export async function loadAndValidatePullRequest({ git, config, }, prNumber, validationConfig) {
    const prData = await fetchPullRequestFromGithub(git, prNumber);
    if (prData === null) {
        throw new FatalMergeToolError('Pull request could not be found.');
    }
    const labels = prData.labels.nodes.map((l) => l.name);
    const githubTargetBranch = prData.baseRefName;
    const { mainBranchName, name, owner } = config.github;
    // Active release trains fetched. May be `null` if e.g. target labeling is disabled
    // and the active release train information is not available/computable.
    let activeReleaseTrains = null;
    let target = null;
    if (config.pullRequest.__noTargetLabeling) {
        // If there is no target labeling, we always target the main branch and treat the PR as
        // if it has been labeled with the `target: major` label (allowing for all types of changes).
        target = { branches: [config.github.mainBranchName], label: targetLabels.TARGET_MAJOR };
    }
    else {
        activeReleaseTrains = await ActiveReleaseTrains.fetch({
            name,
            nextBranchName: mainBranchName,
            owner,
            api: git.github,
        });
        target = await getTargetBranchesAndLabelForPullRequest(activeReleaseTrains, git.github, config, labels, githubTargetBranch);
    }
    const validationFailures = await assertValidPullRequest(prData, validationConfig, config, activeReleaseTrains, target, git);
    const requiredBaseSha = config.pullRequest.requiredBaseCommits &&
        config.pullRequest.requiredBaseCommits[githubTargetBranch];
    const needsCommitMessageFixup = labels.includes(mergeLabels.MERGE_FIX_COMMIT_MESSAGE.name);
    const hasCaretakerNote = labels.includes(mergeLabels.MERGE_CARETAKER_NOTE.name);
    // The parent of the first commit in a PR is the base SHA.
    const baseSha = prData.baseCommitInfo.nodes[0].commit.parents.nodes[0].oid;
    // Typically we would be able to rely on referencing the base revision as the pull
    // request head commit minus the number of commits in the pull request. This is not always
    // reliable when we rebase e.g. the PR with autosquash where the amount of commits could
    // change. We avoid this issue around this by using the resolved base revision so that we are
    // able to reference an explicit SHA before a autosquash rebase could be performed.
    const revisionRange = `${baseSha}..${TEMP_PR_HEAD_BRANCH}`;
    return {
        url: prData.url,
        prNumber,
        labels,
        requiredBaseSha,
        githubTargetBranch,
        needsCommitMessageFixup,
        baseSha,
        revisionRange,
        hasCaretakerNote,
        validationFailures,
        targetBranches: target.branches,
        title: prData.title,
        commitCount: prData.commits.totalCount,
        headSha: prData.headRefOid,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbC1yZXF1ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3ByL21lcmdlL3B1bGwtcmVxdWVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQ0wsdUNBQXVDLEdBRXhDLE1BQU0scUNBQXFDLENBQUM7QUFDN0MsT0FBTyxFQUFDLDBCQUEwQixFQUFDLE1BQU0saUNBQWlDLENBQUM7QUFDM0UsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2xELE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLG1EQUFtRCxDQUFDO0FBQ3RGLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLCtDQUErQyxDQUFDO0FBQ3JGLE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBQzdELE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUt0RCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFrQ3hEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sQ0FBQyxLQUFLLFVBQVUsMEJBQTBCLENBQzlDLEVBQ0UsR0FBRyxFQUNILE1BQU0sR0FPUCxFQUNELFFBQWdCLEVBQ2hCLGdCQUE2QztJQUU3QyxNQUFNLE1BQU0sR0FBRyxNQUFNLDBCQUEwQixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUUvRCxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUUsQ0FBQztRQUNwQixNQUFNLElBQUksbUJBQW1CLENBQUMsa0NBQWtDLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEQsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO0lBRTlDLE1BQU0sRUFBQyxjQUFjLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFFcEQsbUZBQW1GO0lBQ25GLHdFQUF3RTtJQUN4RSxJQUFJLG1CQUFtQixHQUErQixJQUFJLENBQUM7SUFDM0QsSUFBSSxNQUFNLEdBQTZCLElBQUksQ0FBQztJQUU1QyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUMxQyx1RkFBdUY7UUFDdkYsNkZBQTZGO1FBQzdGLE1BQU0sR0FBRyxFQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsS0FBSyxFQUFFLFlBQVksQ0FBQyxZQUFZLEVBQUMsQ0FBQztJQUN4RixDQUFDO1NBQU0sQ0FBQztRQUNOLG1CQUFtQixHQUFHLE1BQU0sbUJBQW1CLENBQUMsS0FBSyxDQUFDO1lBQ3BELElBQUk7WUFDSixjQUFjLEVBQUUsY0FBYztZQUM5QixLQUFLO1lBQ0wsR0FBRyxFQUFFLEdBQUcsQ0FBQyxNQUFNO1NBQ2hCLENBQUMsQ0FBQztRQUVILE1BQU0sR0FBRyxNQUFNLHVDQUF1QyxDQUNwRCxtQkFBbUIsRUFDbkIsR0FBRyxDQUFDLE1BQU0sRUFDVixNQUFNLEVBQ04sTUFBTSxFQUNOLGtCQUFrQixDQUNuQixDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxzQkFBc0IsQ0FDckQsTUFBTSxFQUNOLGdCQUFnQixFQUNoQixNQUFNLEVBQ04sbUJBQW1CLEVBQ25CLE1BQU0sRUFDTixHQUFHLENBQ0osQ0FBQztJQUVGLE1BQU0sZUFBZSxHQUNuQixNQUFNLENBQUMsV0FBVyxDQUFDLG1CQUFtQjtRQUN0QyxNQUFNLENBQUMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDN0QsTUFBTSx1QkFBdUIsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzRixNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWhGLDBEQUEwRDtJQUMxRCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFFM0Usa0ZBQWtGO0lBQ2xGLDBGQUEwRjtJQUMxRix3RkFBd0Y7SUFDeEYsNkZBQTZGO0lBQzdGLG1GQUFtRjtJQUNuRixNQUFNLGFBQWEsR0FBRyxHQUFHLE9BQU8sS0FBSyxtQkFBbUIsRUFBRSxDQUFDO0lBRTNELE9BQU87UUFDTCxHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUc7UUFDZixRQUFRO1FBQ1IsTUFBTTtRQUNOLGVBQWU7UUFDZixrQkFBa0I7UUFDbEIsdUJBQXVCO1FBQ3ZCLE9BQU87UUFDUCxhQUFhO1FBQ2IsZ0JBQWdCO1FBQ2hCLGtCQUFrQjtRQUNsQixjQUFjLEVBQUUsTUFBTSxDQUFDLFFBQVE7UUFDL0IsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLO1FBQ25CLFdBQVcsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7UUFDdEMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxVQUFVO0tBQzNCLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7XG4gIGdldFRhcmdldEJyYW5jaGVzQW5kTGFiZWxGb3JQdWxsUmVxdWVzdCxcbiAgUHVsbFJlcXVlc3RUYXJnZXQsXG59IGZyb20gJy4uL2NvbW1vbi90YXJnZXRpbmcvdGFyZ2V0LWxhYmVsLmpzJztcbmltcG9ydCB7ZmV0Y2hQdWxsUmVxdWVzdEZyb21HaXRodWJ9IGZyb20gJy4uL2NvbW1vbi9mZXRjaC1wdWxsLXJlcXVlc3QuanMnO1xuaW1wb3J0IHtGYXRhbE1lcmdlVG9vbEVycm9yfSBmcm9tICcuL2ZhaWx1cmVzLmpzJztcbmltcG9ydCB7QWN0aXZlUmVsZWFzZVRyYWluc30gZnJvbSAnLi4vLi4vcmVsZWFzZS92ZXJzaW9uaW5nL2FjdGl2ZS1yZWxlYXNlLXRyYWlucy5qcyc7XG5pbXBvcnQge2Fzc2VydFZhbGlkUHVsbFJlcXVlc3R9IGZyb20gJy4uL2NvbW1vbi92YWxpZGF0aW9uL3ZhbGlkYXRlLXB1bGwtcmVxdWVzdC5qcyc7XG5pbXBvcnQge1RFTVBfUFJfSEVBRF9CUkFOQ0h9IGZyb20gJy4vc3RyYXRlZ2llcy9zdHJhdGVneS5qcyc7XG5pbXBvcnQge21lcmdlTGFiZWxzfSBmcm9tICcuLi9jb21tb24vbGFiZWxzL21lcmdlLmpzJztcbmltcG9ydCB7UHVsbFJlcXVlc3RWYWxpZGF0aW9uRmFpbHVyZX0gZnJvbSAnLi4vY29tbW9uL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1mYWlsdXJlLmpzJztcbmltcG9ydCB7QXV0aGVudGljYXRlZEdpdENsaWVudH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2l0L2F1dGhlbnRpY2F0ZWQtZ2l0LWNsaWVudC5qcyc7XG5pbXBvcnQge0dpdGh1YkNvbmZpZywgTmdEZXZDb25maWcsIENhcmV0YWtlckNvbmZpZywgR29vZ2xlU3luY0NvbmZpZ30gZnJvbSAnLi4vLi4vdXRpbHMvY29uZmlnLmpzJztcbmltcG9ydCB7UHVsbFJlcXVlc3RDb25maWcsIFB1bGxSZXF1ZXN0VmFsaWRhdGlvbkNvbmZpZ30gZnJvbSAnLi4vY29uZmlnL2luZGV4LmpzJztcbmltcG9ydCB7dGFyZ2V0TGFiZWxzfSBmcm9tICcuLi9jb21tb24vbGFiZWxzL3RhcmdldC5qcyc7XG5cbi8qKiBJbnRlcmZhY2UgdGhhdCBkZXNjcmliZXMgYSBwdWxsIHJlcXVlc3QuICovXG5leHBvcnQgaW50ZXJmYWNlIFB1bGxSZXF1ZXN0IHtcbiAgLyoqIFVSTCB0byB0aGUgcHVsbCByZXF1ZXN0LiAqL1xuICB1cmw6IHN0cmluZztcbiAgLyoqIE51bWJlciBvZiB0aGUgcHVsbCByZXF1ZXN0LiAqL1xuICBwck51bWJlcjogbnVtYmVyO1xuICAvKiogVGl0bGUgb2YgdGhlIHB1bGwgcmVxdWVzdC4gKi9cbiAgdGl0bGU6IHN0cmluZztcbiAgLyoqIExhYmVscyBhcHBsaWVkIHRvIHRoZSBwdWxsIHJlcXVlc3QuICovXG4gIGxhYmVsczogc3RyaW5nW107XG4gIC8qKiBMaXN0IG9mIGJyYW5jaGVzIHRoaXMgUFIgc2hvdWxkIGJlIG1lcmdlZCBpbnRvLiAqL1xuICB0YXJnZXRCcmFuY2hlczogc3RyaW5nW107XG4gIC8qKiBCcmFuY2ggdGhhdCB0aGUgUFIgdGFyZ2V0cyBpbiB0aGUgR2l0aHViIFVJLiAqL1xuICBnaXRodWJUYXJnZXRCcmFuY2g6IHN0cmluZztcbiAgLyoqIENvdW50IG9mIGNvbW1pdHMgaW4gdGhpcyBwdWxsIHJlcXVlc3QuICovXG4gIGNvbW1pdENvdW50OiBudW1iZXI7XG4gIC8qKiBPcHRpb25hbCBTSEEgdGhhdCB0aGlzIHB1bGwgcmVxdWVzdCBuZWVkcyB0byBiZSBiYXNlZCBvbi4gKi9cbiAgcmVxdWlyZWRCYXNlU2hhPzogc3RyaW5nO1xuICAvKiogV2hldGhlciB0aGUgcHVsbCByZXF1ZXN0IGNvbW1pdCBtZXNzYWdlIGZpeHVwLiAqL1xuICBuZWVkc0NvbW1pdE1lc3NhZ2VGaXh1cDogYm9vbGVhbjtcbiAgLyoqIFdoZXRoZXIgdGhlIHB1bGwgcmVxdWVzdCBoYXMgYSBjYXJldGFrZXIgbm90ZS4gKi9cbiAgaGFzQ2FyZXRha2VyTm90ZTogYm9vbGVhbjtcbiAgLyoqIFRoZSBTSEEgZm9yIHRoZSBmaXJzdCBjb21taXQgdGhlIHB1bGwgcmVxdWVzdCBpcyBiYXNlZCBvbi4gKi9cbiAgYmFzZVNoYTogc3RyaW5nO1xuICAvKiogR2l0IHJldmlzaW9uIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcHVsbCByZXF1ZXN0IGNvbW1pdHMuICovXG4gIHJldmlzaW9uUmFuZ2U6IHN0cmluZztcbiAgLyoqIEEgbGlzdCBvZiB2YWxpZGF0aW9uIGZhaWx1cmVzIGZvdW5kIGZvciB0aGUgcHVsbCByZXF1ZXN0LCBlbXB0eSBpZiBubyBmYWlsdXJlcyBhcmUgZGlzY292ZXJlZC4gKi9cbiAgdmFsaWRhdGlvbkZhaWx1cmVzOiBQdWxsUmVxdWVzdFZhbGlkYXRpb25GYWlsdXJlW107XG4gIC8qKiBUaGUgU0hBIGZvciB0aGUgbGF0ZXN0IGNvbW1pdCBpbiB0aGUgcHVsbCByZXF1ZXN0LiAqL1xuICBoZWFkU2hhOiBzdHJpbmc7XG59XG5cbi8qKlxuICogTG9hZHMgYW5kIHZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIHB1bGwgcmVxdWVzdCBhZ2FpbnN0IHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICogSWYgdGhlIHB1bGwgcmVxdWVzdHMgZmFpbHMsIGEgcHVsbCByZXF1ZXN0IGZhaWx1cmUgaXMgcmV0dXJuZWQuXG4gKlxuICogQHRocm93cyB7RmF0YWxNZXJnZVRvb2xFcnJvcn0gQSBmYXRhbCBlcnJvciBtaWdodCBiZSB0aHJvd24gd2hlbiBlLmcuIHRoZSBwdWxsIHJlcXVlc3RcbiAqICAgZG9lcyBub3QgZXhpc3QgdXBzdHJlYW0uXG4gKiBAdGhyb3dzIHtJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcn0gRXJyb3IgdGhyb3duIGlmIGFuIGludmFsaWQgdGFyZ2V0IGxhYmVsIGlzIGFwcGxpZWQuXG4gKiBAdGhyb3dzIHtJbnZhbGlkVGFyZ2V0QnJhbmNoRXJyb3J9IEVycm9yIHRocm93biBpZiBhbiBpbnZhbGlkIEdpdEh1YiBQUiBkZXN0aW5hdGlvbiBicmFuY2hcbiAqICAgaXMgc2VsZWN0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQW5kVmFsaWRhdGVQdWxsUmVxdWVzdChcbiAge1xuICAgIGdpdCxcbiAgICBjb25maWcsXG4gIH06IHtcbiAgICBnaXQ6IEF1dGhlbnRpY2F0ZWRHaXRDbGllbnQ7XG4gICAgY29uZmlnOiBOZ0RldkNvbmZpZzx7XG4gICAgICBwdWxsUmVxdWVzdDogUHVsbFJlcXVlc3RDb25maWc7XG4gICAgICBnaXRodWI6IEdpdGh1YkNvbmZpZztcbiAgICB9PjtcbiAgfSxcbiAgcHJOdW1iZXI6IG51bWJlcixcbiAgdmFsaWRhdGlvbkNvbmZpZzogUHVsbFJlcXVlc3RWYWxpZGF0aW9uQ29uZmlnLFxuKTogUHJvbWlzZTxQdWxsUmVxdWVzdD4ge1xuICBjb25zdCBwckRhdGEgPSBhd2FpdCBmZXRjaFB1bGxSZXF1ZXN0RnJvbUdpdGh1YihnaXQsIHByTnVtYmVyKTtcblxuICBpZiAocHJEYXRhID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEZhdGFsTWVyZ2VUb29sRXJyb3IoJ1B1bGwgcmVxdWVzdCBjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gIH1cblxuICBjb25zdCBsYWJlbHMgPSBwckRhdGEubGFiZWxzLm5vZGVzLm1hcCgobCkgPT4gbC5uYW1lKTtcbiAgY29uc3QgZ2l0aHViVGFyZ2V0QnJhbmNoID0gcHJEYXRhLmJhc2VSZWZOYW1lO1xuXG4gIGNvbnN0IHttYWluQnJhbmNoTmFtZSwgbmFtZSwgb3duZXJ9ID0gY29uZmlnLmdpdGh1YjtcblxuICAvLyBBY3RpdmUgcmVsZWFzZSB0cmFpbnMgZmV0Y2hlZC4gTWF5IGJlIGBudWxsYCBpZiBlLmcuIHRhcmdldCBsYWJlbGluZyBpcyBkaXNhYmxlZFxuICAvLyBhbmQgdGhlIGFjdGl2ZSByZWxlYXNlIHRyYWluIGluZm9ybWF0aW9uIGlzIG5vdCBhdmFpbGFibGUvY29tcHV0YWJsZS5cbiAgbGV0IGFjdGl2ZVJlbGVhc2VUcmFpbnM6IEFjdGl2ZVJlbGVhc2VUcmFpbnMgfCBudWxsID0gbnVsbDtcbiAgbGV0IHRhcmdldDogUHVsbFJlcXVlc3RUYXJnZXQgfCBudWxsID0gbnVsbDtcblxuICBpZiAoY29uZmlnLnB1bGxSZXF1ZXN0Ll9fbm9UYXJnZXRMYWJlbGluZykge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRhcmdldCBsYWJlbGluZywgd2UgYWx3YXlzIHRhcmdldCB0aGUgbWFpbiBicmFuY2ggYW5kIHRyZWF0IHRoZSBQUiBhc1xuICAgIC8vIGlmIGl0IGhhcyBiZWVuIGxhYmVsZWQgd2l0aCB0aGUgYHRhcmdldDogbWFqb3JgIGxhYmVsIChhbGxvd2luZyBmb3IgYWxsIHR5cGVzIG9mIGNoYW5nZXMpLlxuICAgIHRhcmdldCA9IHticmFuY2hlczogW2NvbmZpZy5naXRodWIubWFpbkJyYW5jaE5hbWVdLCBsYWJlbDogdGFyZ2V0TGFiZWxzLlRBUkdFVF9NQUpPUn07XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlUmVsZWFzZVRyYWlucyA9IGF3YWl0IEFjdGl2ZVJlbGVhc2VUcmFpbnMuZmV0Y2goe1xuICAgICAgbmFtZSxcbiAgICAgIG5leHRCcmFuY2hOYW1lOiBtYWluQnJhbmNoTmFtZSxcbiAgICAgIG93bmVyLFxuICAgICAgYXBpOiBnaXQuZ2l0aHViLFxuICAgIH0pO1xuXG4gICAgdGFyZ2V0ID0gYXdhaXQgZ2V0VGFyZ2V0QnJhbmNoZXNBbmRMYWJlbEZvclB1bGxSZXF1ZXN0KFxuICAgICAgYWN0aXZlUmVsZWFzZVRyYWlucyxcbiAgICAgIGdpdC5naXRodWIsXG4gICAgICBjb25maWcsXG4gICAgICBsYWJlbHMsXG4gICAgICBnaXRodWJUYXJnZXRCcmFuY2gsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRpb25GYWlsdXJlcyA9IGF3YWl0IGFzc2VydFZhbGlkUHVsbFJlcXVlc3QoXG4gICAgcHJEYXRhLFxuICAgIHZhbGlkYXRpb25Db25maWcsXG4gICAgY29uZmlnLFxuICAgIGFjdGl2ZVJlbGVhc2VUcmFpbnMsXG4gICAgdGFyZ2V0LFxuICAgIGdpdCxcbiAgKTtcblxuICBjb25zdCByZXF1aXJlZEJhc2VTaGEgPVxuICAgIGNvbmZpZy5wdWxsUmVxdWVzdC5yZXF1aXJlZEJhc2VDb21taXRzICYmXG4gICAgY29uZmlnLnB1bGxSZXF1ZXN0LnJlcXVpcmVkQmFzZUNvbW1pdHNbZ2l0aHViVGFyZ2V0QnJhbmNoXTtcbiAgY29uc3QgbmVlZHNDb21taXRNZXNzYWdlRml4dXAgPSBsYWJlbHMuaW5jbHVkZXMobWVyZ2VMYWJlbHMuTUVSR0VfRklYX0NPTU1JVF9NRVNTQUdFLm5hbWUpO1xuICBjb25zdCBoYXNDYXJldGFrZXJOb3RlID0gbGFiZWxzLmluY2x1ZGVzKG1lcmdlTGFiZWxzLk1FUkdFX0NBUkVUQUtFUl9OT1RFLm5hbWUpO1xuXG4gIC8vIFRoZSBwYXJlbnQgb2YgdGhlIGZpcnN0IGNvbW1pdCBpbiBhIFBSIGlzIHRoZSBiYXNlIFNIQS5cbiAgY29uc3QgYmFzZVNoYSA9IHByRGF0YS5iYXNlQ29tbWl0SW5mby5ub2Rlc1swXS5jb21taXQucGFyZW50cy5ub2Rlc1swXS5vaWQ7XG5cbiAgLy8gVHlwaWNhbGx5IHdlIHdvdWxkIGJlIGFibGUgdG8gcmVseSBvbiByZWZlcmVuY2luZyB0aGUgYmFzZSByZXZpc2lvbiBhcyB0aGUgcHVsbFxuICAvLyByZXF1ZXN0IGhlYWQgY29tbWl0IG1pbnVzIHRoZSBudW1iZXIgb2YgY29tbWl0cyBpbiB0aGUgcHVsbCByZXF1ZXN0LiBUaGlzIGlzIG5vdCBhbHdheXNcbiAgLy8gcmVsaWFibGUgd2hlbiB3ZSByZWJhc2UgZS5nLiB0aGUgUFIgd2l0aCBhdXRvc3F1YXNoIHdoZXJlIHRoZSBhbW91bnQgb2YgY29tbWl0cyBjb3VsZFxuICAvLyBjaGFuZ2UuIFdlIGF2b2lkIHRoaXMgaXNzdWUgYXJvdW5kIHRoaXMgYnkgdXNpbmcgdGhlIHJlc29sdmVkIGJhc2UgcmV2aXNpb24gc28gdGhhdCB3ZSBhcmVcbiAgLy8gYWJsZSB0byByZWZlcmVuY2UgYW4gZXhwbGljaXQgU0hBIGJlZm9yZSBhIGF1dG9zcXVhc2ggcmViYXNlIGNvdWxkIGJlIHBlcmZvcm1lZC5cbiAgY29uc3QgcmV2aXNpb25SYW5nZSA9IGAke2Jhc2VTaGF9Li4ke1RFTVBfUFJfSEVBRF9CUkFOQ0h9YDtcblxuICByZXR1cm4ge1xuICAgIHVybDogcHJEYXRhLnVybCxcbiAgICBwck51bWJlcixcbiAgICBsYWJlbHMsXG4gICAgcmVxdWlyZWRCYXNlU2hhLFxuICAgIGdpdGh1YlRhcmdldEJyYW5jaCxcbiAgICBuZWVkc0NvbW1pdE1lc3NhZ2VGaXh1cCxcbiAgICBiYXNlU2hhLFxuICAgIHJldmlzaW9uUmFuZ2UsXG4gICAgaGFzQ2FyZXRha2VyTm90ZSxcbiAgICB2YWxpZGF0aW9uRmFpbHVyZXMsXG4gICAgdGFyZ2V0QnJhbmNoZXM6IHRhcmdldC5icmFuY2hlcyxcbiAgICB0aXRsZTogcHJEYXRhLnRpdGxlLFxuICAgIGNvbW1pdENvdW50OiBwckRhdGEuY29tbWl0cy50b3RhbENvdW50LFxuICAgIGhlYWRTaGE6IHByRGF0YS5oZWFkUmVmT2lkLFxuICB9O1xufVxuIl19