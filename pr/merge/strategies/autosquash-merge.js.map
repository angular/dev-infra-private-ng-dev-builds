{"version":3,"file":"autosquash-merge.js","sourceRoot":"","sources":["autosquash-merge.ts"],"names":[],"mappings":"AAQA,OAAO,EAAC,UAAU,IAAI,KAAK,EAAC,MAAM,sBAAsB,CAAC;AACzD,OAAO,EAAC,OAAO,EAAE,IAAI,EAAC,MAAM,WAAW,CAAC;AACxC,OAAO,EAAC,aAAa,EAAC,MAAM,UAAU,CAAC;AAEvC,OAAO,EAAC,aAAa,EAAE,mBAAmB,EAAC,MAAM,eAAe,CAAC;AACjE,OAAO,EAAC,wBAAwB,EAAC,MAAM,gBAAgB,CAAC;AASxD,MAAM,OAAO,uBAAwB,SAAQ,aAAa;IAW/C,KAAK,CAAC,KAAK,CAAC,WAAwB;QAC3C,MAAM,EACJ,kBAAkB,EAClB,cAAc,EACd,aAAa,EACb,uBAAuB,EACvB,OAAO,EACP,QAAQ,GACT,GAAG,WAAW,CAAC;QAQhB,MAAM,4BAA4B,GAAG,IAAI,CAAC,GAAG,CAAC,0BAA0B,EAAE,CAAC;QAC3E,MAAM,SAAS,GAAG,uBAAuB;YACvC,CAAC,CAAC,SAAS;YACX,CAAC,CAAC,EAAC,GAAG,OAAO,CAAC,GAAG,EAAE,mBAAmB,EAAE,MAAM,EAAC,CAAC;QAClD,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,eAAe,EAAE,cAAc,EAAE,OAAO,EAAE,mBAAmB,CAAC,EAAE;YACtF,KAAK,EAAE,SAAS;YAChB,GAAG,EAAE,SAAS;SACf,CAAC,CAAC;QAOH,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,IAAI,EAAE,4BAA4B,CAAC,CAAC,CAAC;QAC/D,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;YACX,eAAe;YACf,IAAI;YACJ,cAAc;YACd,GAAG,gCAAgC,EAAE,IAAI,QAAQ,EAAE;YACnD,aAAa;SACd,CAAC,CAAC;QAIH,MAAM,cAAc,GAAG,IAAI,CAAC,4BAA4B,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;QAKxF,IAAI,cAAc,CAAC,MAAM,EAAE,CAAC;YAC1B,MAAM,IAAI,wBAAwB,CAAC,cAAc,CAAC,CAAC;QACrD,CAAC;QAGD,IAAI,CAAC,0BAA0B,CAAC,cAAc,CAAC,CAAC;QAIhD,MAAM,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;QAEhE,MAAM,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;QAM3D,IAAI,kBAAkB,KAAK,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,CAAC;YACnD,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;gBACjC,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY;gBACxB,WAAW,EAAE,WAAW,CAAC,QAAQ;gBACjC,KAAK,EAAE,QAAQ;aAChB,CAAC,CAAC;YAKH,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAC5C,CAAC;IACH,CAAC;CACF;AAGD,SAAS,gCAAgC;IAKvC,MAAM,UAAU,GAAG,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAC3D,OAAO,IAAI,CAAC,UAAU,EAAE,iDAAiD,CAAC,CAAC;AAC7E,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {setTimeout as sleep} from 'node:timers/promises';\nimport {dirname, join} from 'node:path';\nimport {fileURLToPath} from 'node:url';\nimport {PullRequest} from '../pull-request.js';\nimport {MergeStrategy, TEMP_PR_HEAD_BRANCH} from './strategy.js';\nimport {MergeConflictsFatalError} from '../failures.js';\n\n/**\n * Merge strategy that does not use the Github API for merging. Instead, it fetches\n * all target branches and the PR locally. The PR is then cherry-picked with autosquash\n * enabled into the target branches. The benefit is the support for fixup and squash commits.\n * A notable downside though is that Github does not show the PR as `Merged` due to non\n * fast-forward merges.\n */\nexport class AutosquashMergeStrategy extends MergeStrategy {\n  /**\n   * Merges the specified pull request into the target branches and pushes the target\n   * branches upstream. This method requires the temporary target branches to be fetched\n   * already as we don't want to fetch the target branches per pull request merge. This\n   * would causes unnecessary multiple fetch requests when multiple PRs are merged.\n   *\n   * @throws {GitCommandError} An unknown Git command error occurred that is not\n   *   specific to the pull request merge.\n   * @throws {FatalMergeToolError} A fatal error if the merge could not be performed.\n   */\n  override async merge(pullRequest: PullRequest): Promise<void> {\n    const {\n      githubTargetBranch,\n      targetBranches,\n      revisionRange,\n      needsCommitMessageFixup,\n      baseSha,\n      prNumber,\n    } = pullRequest;\n\n    // We always rebase the pull request so that fixup or squash commits are automatically\n    // collapsed. Git's autosquash functionality does only work in interactive rebases, so\n    // our rebase is always interactive. In reality though, unless a commit message fixup\n    // is desired, we set the `GIT_SEQUENCE_EDITOR` environment variable to `true` so that\n    // the rebase seems interactive to Git, while it's not interactive to the user.\n    // See: https://github.com/git/git/commit/891d4a0313edc03f7e2ecb96edec5d30dc182294.\n    const branchOrRevisionBeforeRebase = this.git.getCurrentBranchOrRevision();\n    const rebaseEnv = needsCommitMessageFixup\n      ? undefined\n      : {...process.env, GIT_SEQUENCE_EDITOR: 'true'};\n    this.git.run(['rebase', '--interactive', '--autosquash', baseSha, TEMP_PR_HEAD_BRANCH], {\n      stdio: 'inherit',\n      env: rebaseEnv,\n    });\n\n    // Update pull requests commits to reference the pull request. This matches what\n    // Github does when pull requests are merged through the Web UI. The motivation is\n    // that it should be easy to determine which pull request contained a given commit.\n    // Note: The filter-branch command relies on the working tree, so we want to make sure\n    // that we are on the initial branch or revision where the merge script has been invoked.\n    this.git.run(['checkout', '-f', branchOrRevisionBeforeRebase]);\n    this.git.run([\n      'filter-branch',\n      '-f',\n      '--msg-filter',\n      `${getCommitMessageFilterScriptPath()} ${prNumber}`,\n      revisionRange, // Range still captures the squashed commits (`base..PR_HEAD`).\n    ]);\n\n    // Perform the actual cherry picking into target branches.\n    // Note: Range still captures the squashed commits (`base..PR_HEAD`).\n    const failedBranches = this.cherryPickIntoTargetBranches(revisionRange, targetBranches);\n\n    // We already checked whether the PR can be cherry-picked into the target branches,\n    // but in case the cherry-pick somehow fails, we still handle the conflicts here. The\n    // commits created through the Github API could be different (i.e. through squash).\n    if (failedBranches.length) {\n      throw new MergeConflictsFatalError(failedBranches);\n    }\n\n    // Push the cherry picked branches upstream.\n    this.pushTargetBranchesUpstream(targetBranches);\n\n    // Allow user to set an amount of time to wait to account for rate limiting of the token usage\n    // during merge otherwise just waits 0 seconds.\n    await sleep(parseInt(process.env['AUTOSQUASH_TIMEOUT'] || '0'));\n\n    await this.createMergeComment(pullRequest, targetBranches);\n\n    // For PRs which do not target the `main` branch on Github, Github does not automatically\n    // close the PR when its commit is pushed into the repository. To ensure these PRs are\n    // correctly marked as closed, we must detect this situation and close the PR via the API after\n    // the upstream pushes are completed.\n    if (githubTargetBranch !== this.git.mainBranchName) {\n      await this.git.github.pulls.update({\n        ...this.git.remoteParams,\n        pull_number: pullRequest.prNumber,\n        state: 'closed',\n      });\n\n      // When a pull request is merged, GitHub automatically closes any linked issues.\n      // This is not the case when the pull request is not merged into the main branch.\n      // This is why we need to manually close the linked issues.\n      await this.closeLinkedIssues(pullRequest);\n    }\n  }\n}\n\n/** Gets the absolute file path to the commit-message filter script. */\nfunction getCommitMessageFilterScriptPath(): string {\n  // This file is getting bundled and ends up in `<pkg-root>/bundles/<chunk>`. We also\n  // bundle the commit-message-filter script as another entry-point and can reference\n  // it relatively as the path is preserved inside `bundles/`.\n  // *Note*: Relying on package resolution is problematic within ESM and with `local-dev.sh`\n  const bundlesDir = dirname(fileURLToPath(import.meta.url));\n  return join(bundlesDir, './pr/merge/strategies/commit-message-filter.mjs');\n}\n"]}