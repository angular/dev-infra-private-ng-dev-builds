{"version":3,"file":"strategy.js","sourceRoot":"","sources":["strategy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Commit, parseCommitMessage} from '../../../commit-message/parse.js';\nimport {AuthenticatedGitClient} from '../../../utils/git/authenticated-git-client.js';\nimport {\n  FatalMergeToolError,\n  MergeConflictsFatalError,\n  MismatchedTargetBranchFatalError,\n  UnsatisfiedBaseShaFatalError,\n} from '../failures.js';\nimport {PullRequest} from '../pull-request.js';\n\n/**\n * Name of a temporary branch that contains the head of a currently-processed PR. Note\n * that a branch name should be used that most likely does not conflict with other local\n * development branches.\n */\nexport const TEMP_PR_HEAD_BRANCH = 'merge_pr_head';\n\n/**\n * Base class for merge strategies. A merge strategy accepts a pull request and\n * merges it into the determined target branches.\n */\nexport abstract class MergeStrategy {\n  constructor(protected git: AuthenticatedGitClient) {}\n\n  /**\n   * Prepares a merge of the given pull request. The strategy by default will\n   * fetch all target branches and the pull request into local temporary branches.\n   */\n  async prepare(pullRequest: PullRequest) {\n    this.fetchTargetBranches(\n      pullRequest.targetBranches,\n      `pull/${pullRequest.prNumber}/head:${TEMP_PR_HEAD_BRANCH}`,\n    );\n  }\n\n  /**\n   * Performs the merge of the given pull request. This needs to be implemented\n   * by individual merge strategies.\n   *\n   * @throws {FatalMergeToolError} A fatal error has occurred when attempting to merge the\n   *   pull request.\n   */\n  abstract merge(pullRequest: PullRequest): Promise<void>;\n\n  /**\n   * Checks to confirm that a pull request in its current state is able to merge as expected to\n   * the targeted branches. This method notably does not commit any attempted cherry-picks during\n   * its check, but instead leaves this to the merging action.\n   *\n   * @throws {GitCommandError} An unknown Git command error occurred that is not\n   *   specific to the pull request merge.\n   * @throws {UnsatisfiedBaseShaFatalError} A fatal error if a specific is required to be present\n   *   in the pull requests branch and is not present in that branch.\n   * @throws {MismatchedTargetBranchFatalError} A fatal error if the pull request does not target\n   *   a branch via the Github UI that is managed by merge tooling.\n   */\n  async check(pullRequest: PullRequest): Promise<void> {\n    const {githubTargetBranch, targetBranches, requiredBaseSha} = pullRequest;\n    // If the pull request does not have its base branch set to any determined target\n    // branch, we cannot merge using the API.\n    if (targetBranches.every((t) => t !== githubTargetBranch)) {\n      throw new MismatchedTargetBranchFatalError(targetBranches);\n    }\n\n    // In cases where a required base commit is specified for this pull request, check if\n    // the pull request contains the given commit. If not, return a pull request failure.\n    // This check is useful for enforcing that PRs are rebased on top of a given commit.\n    // e.g. a commit that changes the code ownership validation. PRs which are not rebased\n    // could bypass new codeowner ship rules.\n    if (requiredBaseSha && !this.git.hasCommit(TEMP_PR_HEAD_BRANCH, requiredBaseSha)) {\n      throw new UnsatisfiedBaseShaFatalError();\n    }\n\n    // First cherry-pick the PR into all local target branches in dry-run mode. This is\n    // purely for testing so that we can figure out whether the PR can be cherry-picked\n    // into the other target branches. We don't want to merge the PR through the API, and\n    // then run into cherry-pick conflicts after the initial merge already completed.\n    await this._assertMergeableOrThrow(pullRequest, targetBranches);\n  }\n\n  /** Cleans up the pull request merge. e.g. deleting temporary local branches. */\n  async cleanup(pullRequest: PullRequest) {\n    // Delete all temporary target branches.\n    pullRequest.targetBranches.forEach((branchName) =>\n      this.git.run(['branch', '-D', this.getLocalTargetBranchName(branchName)]),\n    );\n\n    // Delete temporary branch for the pull request head.\n    this.git.run(['branch', '-D', TEMP_PR_HEAD_BRANCH]);\n  }\n\n  /** Gets a deterministic local branch name for a given branch. */\n  protected getLocalTargetBranchName(targetBranch: string): string {\n    return `merge_pr_target_${targetBranch.replace(/\\//g, '_')}`;\n  }\n\n  /**\n   * Cherry-picks the given revision range into the specified target branches.\n   * @returns A list of branches for which the revisions could not be cherry-picked into.\n   */\n  protected cherryPickIntoTargetBranches(\n    revisionRange: string,\n    targetBranches: string[],\n    options: {\n      dryRun?: boolean;\n      linkToOriginalCommits?: boolean;\n    } = {},\n  ) {\n    const cherryPickArgs = [revisionRange];\n    const failedBranches: string[] = [];\n\n    const revisionCountOutput = this.git.run(['rev-list', '--count', revisionRange]);\n    const revisionCount = Number(revisionCountOutput.stdout.trim());\n    if (isNaN(revisionCount)) {\n      throw new FatalMergeToolError(\n        'Unexpected revision range for cherry-picking. No commit count could be determined.',\n      );\n    }\n\n    if (options.linkToOriginalCommits) {\n      // We add `-x` when cherry-picking as that will allow us to easily jump to original\n      // commits for cherry-picked commits. With that flag set, Git will automatically append\n      // the original SHA/revision to the commit message. e.g. `(cherry picked from commit <..>)`.\n      // https://git-scm.com/docs/git-cherry-pick#Documentation/git-cherry-pick.txt--x.\n      cherryPickArgs.push('-x');\n    }\n\n    // Cherry-pick the refspec into all determined target branches.\n    for (const branchName of targetBranches) {\n      const localTargetBranch = this.getLocalTargetBranchName(branchName);\n      // Checkout the local target branch.\n      this.git.run(['checkout', localTargetBranch]);\n      // Cherry-pick the refspec into the target branch.\n      const cherryPickResult = this.git.runGraceful(['cherry-pick', ...cherryPickArgs]);\n      if (cherryPickResult.status !== 0) {\n        // Abort the failed cherry-pick. We do this because Git persists the failed\n        // cherry-pick state globally in the repository. This could prevent future\n        // pull request merges as a Git thinks a cherry-pick is still in progress.\n        this.git.runGraceful(['cherry-pick', '--abort']);\n        failedBranches.push(branchName);\n      }\n      // If we run with dry run mode, we reset the local target branch so that all dry-run\n      // cherry-pick changes are discard. Changes are applied to the working tree and index.\n      if (options.dryRun) {\n        this.git.run(['reset', '--hard', `HEAD~${revisionCount}`]);\n      }\n    }\n    return failedBranches;\n  }\n\n  /**\n   * Fetches the given target branches. Also accepts a list of additional refspecs that\n   * should be fetched. This is helpful as multiple slow fetches could be avoided.\n   */\n  protected fetchTargetBranches(names: string[], ...extraRefspecs: string[]) {\n    const fetchRefspecs = names.map((targetBranch) => {\n      const localTargetBranch = this.getLocalTargetBranchName(targetBranch);\n      return `refs/heads/${targetBranch}:${localTargetBranch}`;\n    });\n    // Fetch all target branches with a single command. We don't want to fetch them\n    // individually as that could cause an unnecessary slow-down.\n    this.git.run([\n      'fetch',\n      '-q',\n      '-f',\n      this.git.getRepoGitUrl(),\n      ...fetchRefspecs,\n      ...extraRefspecs,\n    ]);\n  }\n\n  /** Pushes the given target branches upstream. */\n  protected pushTargetBranchesUpstream(names: string[]) {\n    const pushRefspecs = names.map((targetBranch) => {\n      const localTargetBranch = this.getLocalTargetBranchName(targetBranch);\n      return `${localTargetBranch}:refs/heads/${targetBranch}`;\n    });\n    // Push all target branches with a single command if we don't run in dry-run mode.\n    // We don't want to push them individually as that could cause an unnecessary slow-down.\n    this.git.run(['push', '--atomic', this.git.getRepoGitUrl(), ...pushRefspecs]);\n  }\n\n  /** Asserts that given pull request could be merged into the given target branches. */\n  protected async _assertMergeableOrThrow(\n    {revisionRange}: PullRequest,\n    targetBranches: string[],\n  ): Promise<void> {\n    const failedBranches = this.cherryPickIntoTargetBranches(revisionRange, targetBranches, {\n      dryRun: true,\n    });\n\n    if (failedBranches.length) {\n      throw new MergeConflictsFatalError(failedBranches);\n    }\n  }\n\n  /** Gets all commit messages of commits in the pull request. */\n  protected async getPullRequestCommits({prNumber}: PullRequest): Promise<\n    {\n      message: string;\n      parsed: Commit;\n    }[]\n  > {\n    const allCommits = await this.git.github.paginate(this.git.github.pulls.listCommits, {\n      ...this.git.remoteParams,\n      pull_number: prNumber,\n    });\n\n    return allCommits.map(({commit: {message}}) => ({\n      message,\n      parsed: parseCommitMessage(message),\n    }));\n  }\n}\n"]}