{"version":3,"file":"api-merge.js","sourceRoot":"","sources":["api-merge.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RestEndpointMethodTypes} from '@octokit/plugin-rest-endpoint-methods';\n\nimport {AuthenticatedGitClient} from '../../../utils/git/authenticated-git-client.js';\nimport {GithubApiMergeMethod, GithubApiMergeStrategyConfig} from '../../config/index.js';\nimport {PullRequest} from '../pull-request.js';\n\nimport {isGithubApiError} from '../../../utils/git/github.js';\nimport {FatalMergeToolError, MergeConflictsFatalError} from '../failures.js';\nimport {Prompt} from '../../../utils/prompt.js';\nimport {AutosquashMergeStrategy} from './autosquash-merge.js';\nimport {Commit, parseCommitMessage} from '../../../commit-message/parse.js';\nimport {TEMP_PR_HEAD_BRANCH} from './strategy.js';\n\n/** Type describing the parameters for the Octokit `merge` API endpoint. */\ntype OctokitMergeParams = RestEndpointMethodTypes['pulls']['merge']['parameters'];\n\n/** Separator between commit message header and body. */\nconst COMMIT_HEADER_SEPARATOR = '\\n\\n';\n\n/** Interface describing a pull request commit. */\ninterface PullRequestCommit {\n  message: string;\n  parsed: Commit;\n}\n\n/**\n * Merge strategy that primarily leverages the Github API. The strategy merges a given\n * pull request into a target branch using the API. This ensures that Github displays\n * the pull request as merged. The merged commits are then cherry-picked into the remaining\n * target branches using the local Git instance. The benefit is that the Github merged state\n * is properly set.\n *\n * A notable downside is that fixup or squash commits are not supported when `auto` merge\n * method is not used, as the Github API does not support this.\n */\nexport class GithubApiMergeStrategy extends AutosquashMergeStrategy {\n  constructor(\n    git: AuthenticatedGitClient,\n    private config: GithubApiMergeStrategyConfig,\n  ) {\n    super(git);\n  }\n\n  /**\n   * Merges the specified pull request via the Github API, cherry-picks the change into the other\n   * target branhces and pushes the branches upstream.\n   *\n   * @throws {GitCommandError} An unknown Git command error occurred that is not\n   *   specific to the pull request merge.\n   * @throws {FatalMergeToolError} A fatal error if the merge could not be performed.\n   */\n  override async merge(pullRequest: PullRequest): Promise<void> {\n    const {githubTargetBranch, prNumber, needsCommitMessageFixup, targetBranches} = pullRequest;\n    const cherryPickTargetBranches = targetBranches.filter((b) => b !== githubTargetBranch);\n    const commits = await this.getPullRequestCommits(pullRequest);\n    const {squashCount, fixupCount, normalCommitsCount} = await this.getCommitsInfo(pullRequest);\n    const method = this.getMergeActionFromPullRequest(pullRequest);\n    let pullRequestCommitCount = pullRequest.commitCount;\n    const mergeOptions: OctokitMergeParams = {\n      pull_number: prNumber,\n      merge_method: method === 'auto' ? 'rebase' : method,\n      ...this.git.remoteParams,\n    };\n\n    // When the merge method is `auto`, the merge strategy will determine the best merge method\n    // based on the pull request's commits.\n    if (method === 'auto') {\n      const hasFixUpOrSquashAndMultipleCommits =\n        normalCommitsCount > 1 && (fixupCount > 0 || squashCount > 0);\n\n      // If the PR has fixup/squash commits against multiple normal commits, or if the\n      // commit message needs to be fixed up, delegate to the autosquash merge strategy.\n      if (needsCommitMessageFixup || hasFixUpOrSquashAndMultipleCommits) {\n        return super.merge(pullRequest);\n      }\n\n      const hasOnlyFixUpForOneCommit =\n        normalCommitsCount === 1 && fixupCount > 0 && squashCount === 0;\n\n      const hasOnlySquashForOneCommit = normalCommitsCount === 1 && squashCount > 1;\n\n      // If the PR has only one normal commit and some fixup commits, the PR is squashed.\n      // The commit message from the single normal commit is used.\n      if (hasOnlyFixUpForOneCommit) {\n        mergeOptions.merge_method = 'squash';\n        pullRequestCommitCount = 1;\n\n        // The first commit is the correct one, whatever follows are fixups.\n        const [title, message = ''] = commits[0].message.split(COMMIT_HEADER_SEPARATOR);\n\n        mergeOptions.commit_title = title;\n        mergeOptions.commit_message = message;\n\n        // If the PR has only one normal commit and more than one squash commit, the PR is\n        // squashed and the user is prompted to edit the commit message.\n      } else if (hasOnlySquashForOneCommit) {\n        mergeOptions.merge_method = 'squash';\n        pullRequestCommitCount = 1;\n\n        await this._promptCommitMessageEdit(pullRequest, mergeOptions);\n      }\n    }\n\n    if (needsCommitMessageFixup) {\n      // Commit message fixup does not work with other merge methods as the Github API only\n      // allows commit message modifications for squash merging.\n      if (method !== 'squash') {\n        throw new FatalMergeToolError(\n          `Unable to fixup commit message of pull request. Commit message can only be ` +\n            `modified if the PR is merged using squash.`,\n        );\n      }\n\n      await this._promptCommitMessageEdit(pullRequest, mergeOptions);\n    }\n\n    let mergeStatusCode: number;\n    let mergeResponseMessage: string;\n    let targetSha: string;\n\n    try {\n      // Merge the pull request using the Github API into the selected base branch.\n      const result = await this.git.github.pulls.merge(mergeOptions);\n\n      mergeStatusCode = result.status;\n      mergeResponseMessage = result.data.message;\n      targetSha = result.data.sha;\n    } catch (e) {\n      // Note: Github usually returns `404` as status code if the API request uses a\n      // token with insufficient permissions. Github does this because it doesn't want\n      // to leak whether a repository exists or not. In our case we expect a certain\n      // repository to exist, so we always treat this as a permission failure.\n      if (isGithubApiError(e) && (e.status === 403 || e.status === 404)) {\n        throw new FatalMergeToolError('Insufficient Github API permissions to merge pull request.');\n      }\n      throw e;\n    }\n\n    // https://developer.github.com/v3/pulls/#response-if-merge-cannot-be-performed\n    // Pull request cannot be merged due to merge conflicts.\n    if (mergeStatusCode === 405) {\n      throw new MergeConflictsFatalError([githubTargetBranch]);\n    }\n    if (mergeStatusCode !== 200) {\n      throw new FatalMergeToolError(\n        `Unexpected merge status code: ${mergeStatusCode}: ${mergeResponseMessage}`,\n      );\n    }\n\n    // Workaround for fatal: refusing to fetch into branch 'refs/heads/merge_pr_target_main' checked out at ...\n    // Cannot find where but `merge_pr_target_main` is being set as the current branch.\n    // TODO: remove after finding the root cause.\n    this.git.run(['checkout', TEMP_PR_HEAD_BRANCH]);\n\n    // Refresh the target branch the PR has been merged into through the API. We need\n    // to re-fetch as otherwise we cannot cherry-pick the new commits into the remaining\n    // target branches. Also, this is needed fo the merge comment to get the correct commit SHA.\n    this.fetchTargetBranches([githubTargetBranch]);\n\n    // If the PR does not need to be merged into any other target branches,\n    // we exit here as we already completed the merge.\n    if (!cherryPickTargetBranches.length) {\n      await this.createMergeComment(pullRequest, targetBranches);\n\n      return;\n    }\n\n    // Cherry pick the merged commits into the remaining target branches.\n    const failedBranches = await this.cherryPickIntoTargetBranches(\n      // Number of commits that have landed in the target branch. This could vary from\n      // the count of commits in the PR due to squashing.\n      `${targetSha}~${pullRequestCommitCount}..${targetSha}`,\n      cherryPickTargetBranches,\n      {\n        // Commits that have been created by the Github API do not necessarily contain\n        // a reference to the source pull request (unless the squash strategy is used).\n        // To ensure that original commits can be found when a commit is viewed in a\n        // target branch, we add a link to the original commits when cherry-picking.\n        linkToOriginalCommits: true,\n      },\n    );\n\n    // We already checked whether the PR can be cherry-picked into the target branches,\n    // but in case the cherry-pick somehow fails, we still handle the conflicts here. The\n    // commits created through the Github API could be different (i.e. through squash).\n    if (failedBranches.length) {\n      throw new MergeConflictsFatalError(failedBranches);\n    }\n\n    this.pushTargetBranchesUpstream(cherryPickTargetBranches);\n    await this.createMergeComment(pullRequest, targetBranches);\n  }\n\n  /**\n   * Prompts the user for the commit message changes. Unlike as in the autosquash merge\n   * strategy, we cannot start an interactive rebase because we merge using the Github API.\n   * The Github API only allows modifications to PR title and body for squash merges.\n   */\n  private async _promptCommitMessageEdit(\n    pullRequest: PullRequest,\n    mergeOptions: OctokitMergeParams,\n  ) {\n    const commitMessage = await this.getDefaultSquashCommitMessage(pullRequest);\n    const result = await Prompt.editor({\n      message: 'Please update the commit message',\n      default: commitMessage,\n    });\n\n    // Split the new message into title and message. This is necessary because the\n    // Github API expects title and message to be passed separately.\n    const [newTitle, ...newMessage] = result.split(COMMIT_HEADER_SEPARATOR);\n\n    // Update the merge options so that the changes are reflected in there.\n    mergeOptions.commit_title = `${newTitle} (#${pullRequest.prNumber})`;\n    mergeOptions.commit_message = newMessage.join(COMMIT_HEADER_SEPARATOR);\n  }\n\n  /**\n   * Gets a commit message for the given pull request. Github by default concatenates\n   * multiple commit messages if a PR is merged in squash mode. We try to replicate this\n   * behavior here so that we have a default commit message that can be fixed up.\n   */\n  private async getDefaultSquashCommitMessage(pullRequest: PullRequest): Promise<string> {\n    const commits = await this.getPullRequestCommits(pullRequest);\n    const messageBase = `${pullRequest.title}${COMMIT_HEADER_SEPARATOR}`;\n    if (commits.length <= 1) {\n      return `${messageBase}${commits[0].parsed.body}`;\n    }\n    const joinedMessages = commits.map((c) => `* ${c.message}`).join(COMMIT_HEADER_SEPARATOR);\n    return `${messageBase}${joinedMessages}`;\n  }\n\n  /** Determines the merge action from the given pull request. */\n  private getMergeActionFromPullRequest({labels}: PullRequest): GithubApiMergeMethod {\n    if (this.config.labels) {\n      const matchingLabel = this.config.labels.find(({pattern}) => labels.includes(pattern));\n      if (matchingLabel !== undefined) {\n        return matchingLabel.method;\n      }\n    }\n    return this.config.default;\n  }\n\n  /** Returns information about the commits in the pull request. */\n  private async getCommitsInfo(pullRequest: PullRequest): Promise<\n    Readonly<{\n      fixupCount: number;\n      squashCount: number;\n      normalCommitsCount: number;\n    }>\n  > {\n    const commits = await this.getPullRequestCommits(pullRequest);\n    const commitsInfo = {\n      fixupCount: 0,\n      squashCount: 0,\n      normalCommitsCount: 1,\n    };\n\n    if (commits.length === 1) {\n      return commitsInfo;\n    }\n\n    for (let index = 1; index < commits.length; index++) {\n      const {\n        parsed: {isFixup, isSquash},\n      } = commits[index];\n\n      if (isFixup) {\n        commitsInfo.fixupCount++;\n      } else if (isSquash) {\n        commitsInfo.squashCount++;\n      } else {\n        commitsInfo.normalCommitsCount++;\n      }\n    }\n\n    return commitsInfo;\n  }\n\n  /** Commits of the pull request. */\n  private commits: PullRequestCommit[] | undefined;\n  /** Gets all commit messages of commits in the pull request. */\n  protected async getPullRequestCommits({prNumber}: PullRequest): Promise<PullRequestCommit[]> {\n    if (this.commits) {\n      return this.commits;\n    }\n\n    const allCommits = await this.git.github.paginate(this.git.github.pulls.listCommits, {\n      ...this.git.remoteParams,\n      pull_number: prNumber,\n    });\n\n    this.commits = allCommits.map(({commit: {message}}) => ({\n      message,\n      parsed: parseCommitMessage(message),\n    }));\n\n    return this.commits;\n  }\n}\n"]}