/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Minimatch } from 'minimatch';
import fs from 'fs';
import * as jsonc from '../../tools/esm-interop/jsonc-parser.js';
/** Error class used when the Google Sync configuration is invalid. */
export class InvalidGoogleSyncConfigError extends Error {
}
/** Transforms the given sync configuration into a file match function. */
export function transformConfigIntoMatcher(config) {
    const syncedFilePatterns = config.syncedFilePatterns.map((p) => new Minimatch(p));
    const alwaysExternalFilePatterns = config.alwaysExternalFilePatterns.map((p) => new Minimatch(p));
    const separateFilePatterns = config.separateFilePatterns.map((p) => new Minimatch(p));
    // match everything that needs to be synced except external and separate sync files
    const ngSyncMatchFn = (projectRelativePath) => syncedFilePatterns.some((p) => p.match(projectRelativePath)) &&
        alwaysExternalFilePatterns.every((p) => !p.match(projectRelativePath)) &&
        separateFilePatterns.every((p) => !p.match(projectRelativePath));
    // match only files that need to be synced separately
    const separateSyncMatchFn = (projectRelativePath) => separateFilePatterns.some((p) => p.match(projectRelativePath)) &&
        alwaysExternalFilePatterns.every((p) => !p.match(projectRelativePath));
    return { ngSyncMatchFn, separateSyncMatchFn };
}
/**
 * Reads the configuration file from the given path.
 *
 * @throws {InvalidGoogleSyncConfigError} If the configuration is invalid.
 */
export async function getGoogleSyncConfig(absolutePath) {
    const content = await fs.promises.readFile(absolutePath, 'utf8');
    const errors = [];
    const config = jsonc.parse(content, errors);
    if (errors.length !== 0) {
        throw new InvalidGoogleSyncConfigError(`Google Sync Configuration is invalid: ` +
            errors.map((e) => jsonc.printParseErrorCode(e.error)).join('\n'));
    }
    const matchFns = transformConfigIntoMatcher(config);
    return {
        config,
        ngMatchFn: matchFns.ngSyncMatchFn,
        separateMatchFn: matchFns.separateSyncMatchFn,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZzMtc3luYy1jb25maWcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9uZy1kZXYvdXRpbHMvZzMtc3luYy1jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNwQyxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDcEIsT0FBTyxLQUFLLEtBQUssTUFBTSx5Q0FBeUMsQ0FBQztBQXdCakUsc0VBQXNFO0FBQ3RFLE1BQU0sT0FBTyw0QkFBNkIsU0FBUSxLQUFLO0NBQUc7QUFFMUQsMEVBQTBFO0FBQzFFLE1BQU0sVUFBVSwwQkFBMEIsQ0FBQyxNQUF3QjtJQUlqRSxNQUFNLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEYsTUFBTSwwQkFBMEIsR0FBRyxNQUFNLENBQUMsMEJBQTBCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xHLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV0RixtRkFBbUY7SUFDbkYsTUFBTSxhQUFhLEdBQUcsQ0FBQyxtQkFBMkIsRUFBRSxFQUFFLENBQ3BELGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzVELDBCQUEwQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDdEUsb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO0lBRW5FLHFEQUFxRDtJQUNyRCxNQUFNLG1CQUFtQixHQUFHLENBQUMsbUJBQTJCLEVBQUUsRUFBRSxDQUMxRCxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM5RCwwQkFBMEIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7SUFFekUsT0FBTyxFQUFDLGFBQWEsRUFBRSxtQkFBbUIsRUFBQyxDQUFDO0FBQzlDLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLEtBQUssVUFBVSxtQkFBbUIsQ0FBQyxZQUFvQjtJQUs1RCxNQUFNLE9BQU8sR0FBRyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNqRSxNQUFNLE1BQU0sR0FBdUIsRUFBRSxDQUFDO0lBQ3RDLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBcUIsQ0FBQztJQUNoRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDeEIsTUFBTSxJQUFJLDRCQUE0QixDQUNwQyx3Q0FBd0M7WUFDdEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDbkUsQ0FBQztJQUNKLENBQUM7SUFDRCxNQUFNLFFBQVEsR0FBRywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwRCxPQUFPO1FBQ0wsTUFBTTtRQUNOLFNBQVMsRUFBRSxRQUFRLENBQUMsYUFBYTtRQUNqQyxlQUFlLEVBQUUsUUFBUSxDQUFDLG1CQUFtQjtLQUM5QyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge01pbmltYXRjaH0gZnJvbSAnbWluaW1hdGNoJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBqc29uYyBmcm9tICcuLi8uLi90b29scy9lc20taW50ZXJvcC9qc29uYy1wYXJzZXIuanMnO1xuXG4vKiogQ29uZmlndXJhdGlvbiBkZXNjcmliaW5nIGhvdyBmaWxlcyBhcmUgc3luY2VkIGludG8gR29vZ2xlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBHb29nbGVTeW5jQ29uZmlnIHtcbiAgLyoqXG4gICAqIFBhdHRlcm5zIG1hdGNoaW5nIGZpbGVzIHdoaWNoIGFyZSBzeW5jZWQgaW50byBHb29nbGUuIFBhdHRlcm5zXG4gICAqIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcHJvamVjdCBkaXJlY3RvcnkuXG4gICAqL1xuICBzeW5jZWRGaWxlUGF0dGVybnM6IHN0cmluZ1tdO1xuICAvKipcbiAgICogUGF0dGVybnMgbWF0Y2hpbmcgZmlsZXMgd2hpY2ggYXJlIG5ldmVyIHN5bmNlZCBpbnRvIEdvb2dsZS4gUGF0dGVybnNcbiAgICogc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBwcm9qZWN0IGRpcmVjdG9yeS5cbiAgICovXG4gIGFsd2F5c0V4dGVybmFsRmlsZVBhdHRlcm5zOiBzdHJpbmdbXTtcbiAgLyoqXG4gICAqIFBhdHRlcm5zIG1hdGNoaW5nIGZpbGVzIHdoaWNoIG5lZWQgdG8gYmUgc3luY2VkIHNlcGFyYXRlbHkuXG4gICAqIFBhdHRlcm5zIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcHJvamVjdCBkaXJlY3RvcnkuXG4gICAqL1xuICBzZXBhcmF0ZUZpbGVQYXR0ZXJuczogc3RyaW5nW107XG59XG5cbi8qKiBEZXNjcmliZXMgYSBmdW5jdGlvbiBmb3IgdGVzdGluZyBpZiBhIGZpbGUgaXMgc3luY2VkLiAqL1xuZXhwb3J0IHR5cGUgU3luY0ZpbGVNYXRjaEZuID0gKHByb2plY3RSZWxhdGl2ZVBhdGg6IHN0cmluZykgPT4gYm9vbGVhbjtcblxuLyoqIEVycm9yIGNsYXNzIHVzZWQgd2hlbiB0aGUgR29vZ2xlIFN5bmMgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRHb29nbGVTeW5jQ29uZmlnRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKiogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gc3luYyBjb25maWd1cmF0aW9uIGludG8gYSBmaWxlIG1hdGNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUNvbmZpZ0ludG9NYXRjaGVyKGNvbmZpZzogR29vZ2xlU3luY0NvbmZpZyk6IHtcbiAgbmdTeW5jTWF0Y2hGbjogU3luY0ZpbGVNYXRjaEZuO1xuICBzZXBhcmF0ZVN5bmNNYXRjaEZuOiBTeW5jRmlsZU1hdGNoRm47XG59IHtcbiAgY29uc3Qgc3luY2VkRmlsZVBhdHRlcm5zID0gY29uZmlnLnN5bmNlZEZpbGVQYXR0ZXJucy5tYXAoKHApID0+IG5ldyBNaW5pbWF0Y2gocCkpO1xuICBjb25zdCBhbHdheXNFeHRlcm5hbEZpbGVQYXR0ZXJucyA9IGNvbmZpZy5hbHdheXNFeHRlcm5hbEZpbGVQYXR0ZXJucy5tYXAoKHApID0+IG5ldyBNaW5pbWF0Y2gocCkpO1xuICBjb25zdCBzZXBhcmF0ZUZpbGVQYXR0ZXJucyA9IGNvbmZpZy5zZXBhcmF0ZUZpbGVQYXR0ZXJucy5tYXAoKHApID0+IG5ldyBNaW5pbWF0Y2gocCkpO1xuXG4gIC8vIG1hdGNoIGV2ZXJ5dGhpbmcgdGhhdCBuZWVkcyB0byBiZSBzeW5jZWQgZXhjZXB0IGV4dGVybmFsIGFuZCBzZXBhcmF0ZSBzeW5jIGZpbGVzXG4gIGNvbnN0IG5nU3luY01hdGNoRm4gPSAocHJvamVjdFJlbGF0aXZlUGF0aDogc3RyaW5nKSA9PlxuICAgIHN5bmNlZEZpbGVQYXR0ZXJucy5zb21lKChwKSA9PiBwLm1hdGNoKHByb2plY3RSZWxhdGl2ZVBhdGgpKSAmJlxuICAgIGFsd2F5c0V4dGVybmFsRmlsZVBhdHRlcm5zLmV2ZXJ5KChwKSA9PiAhcC5tYXRjaChwcm9qZWN0UmVsYXRpdmVQYXRoKSkgJiZcbiAgICBzZXBhcmF0ZUZpbGVQYXR0ZXJucy5ldmVyeSgocCkgPT4gIXAubWF0Y2gocHJvamVjdFJlbGF0aXZlUGF0aCkpO1xuXG4gIC8vIG1hdGNoIG9ubHkgZmlsZXMgdGhhdCBuZWVkIHRvIGJlIHN5bmNlZCBzZXBhcmF0ZWx5XG4gIGNvbnN0IHNlcGFyYXRlU3luY01hdGNoRm4gPSAocHJvamVjdFJlbGF0aXZlUGF0aDogc3RyaW5nKSA9PlxuICAgIHNlcGFyYXRlRmlsZVBhdHRlcm5zLnNvbWUoKHApID0+IHAubWF0Y2gocHJvamVjdFJlbGF0aXZlUGF0aCkpICYmXG4gICAgYWx3YXlzRXh0ZXJuYWxGaWxlUGF0dGVybnMuZXZlcnkoKHApID0+ICFwLm1hdGNoKHByb2plY3RSZWxhdGl2ZVBhdGgpKTtcblxuICByZXR1cm4ge25nU3luY01hdGNoRm4sIHNlcGFyYXRlU3luY01hdGNoRm59O1xufVxuXG4vKipcbiAqIFJlYWRzIHRoZSBjb25maWd1cmF0aW9uIGZpbGUgZnJvbSB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAdGhyb3dzIHtJbnZhbGlkR29vZ2xlU3luY0NvbmZpZ0Vycm9yfSBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0R29vZ2xlU3luY0NvbmZpZyhhYnNvbHV0ZVBhdGg6IHN0cmluZyk6IFByb21pc2U8e1xuICBuZ01hdGNoRm46IFN5bmNGaWxlTWF0Y2hGbjtcbiAgc2VwYXJhdGVNYXRjaEZuOiBTeW5jRmlsZU1hdGNoRm47XG4gIGNvbmZpZzogR29vZ2xlU3luY0NvbmZpZztcbn0+IHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGFic29sdXRlUGF0aCwgJ3V0ZjgnKTtcbiAgY29uc3QgZXJyb3JzOiBqc29uYy5QYXJzZUVycm9yW10gPSBbXTtcbiAgY29uc3QgY29uZmlnID0ganNvbmMucGFyc2UoY29udGVudCwgZXJyb3JzKSBhcyBHb29nbGVTeW5jQ29uZmlnO1xuICBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkR29vZ2xlU3luY0NvbmZpZ0Vycm9yKFxuICAgICAgYEdvb2dsZSBTeW5jIENvbmZpZ3VyYXRpb24gaXMgaW52YWxpZDogYCArXG4gICAgICAgIGVycm9ycy5tYXAoKGUpID0+IGpzb25jLnByaW50UGFyc2VFcnJvckNvZGUoZS5lcnJvcikpLmpvaW4oJ1xcbicpLFxuICAgICk7XG4gIH1cbiAgY29uc3QgbWF0Y2hGbnMgPSB0cmFuc2Zvcm1Db25maWdJbnRvTWF0Y2hlcihjb25maWcpO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZyxcbiAgICBuZ01hdGNoRm46IG1hdGNoRm5zLm5nU3luY01hdGNoRm4sXG4gICAgc2VwYXJhdGVNYXRjaEZuOiBtYXRjaEZucy5zZXBhcmF0ZVN5bmNNYXRjaEZuLFxuICB9O1xufVxuIl19