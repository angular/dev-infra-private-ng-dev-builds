{"version":3,"file":"g3-sync-config.js","sourceRoot":"","sources":["g3-sync-config.ts"],"names":[],"mappings":"AAQA,OAAO,EAAC,SAAS,EAAC,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,MAAM,IAAI,CAAC;AACpB,OAAO,KAAK,KAAK,MAAM,cAAc,CAAC;AAyBtC,MAAM,OAAO,4BAA6B,SAAQ,KAAK;CAAG;AAG1D,MAAM,UAAU,0BAA0B,CAAC,MAAwB;IAIjE,MAAM,kBAAkB,GAAG,MAAM,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAClF,MAAM,0BAA0B,GAAG,MAAM,CAAC,0BAA0B,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAClG,MAAM,oBAAoB,GAAG,MAAM,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAGtF,MAAM,aAAa,GAAG,CAAC,mBAA2B,EAAE,EAAE,CACpD,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;QAC5D,0BAA0B,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;QACtE,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC;IAGnE,MAAM,mBAAmB,GAAG,CAAC,mBAA2B,EAAE,EAAE,CAC1D,oBAAoB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC;QAC9D,0BAA0B,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC;IAEzE,OAAO,EAAC,aAAa,EAAE,mBAAmB,EAAC,CAAC;AAC9C,CAAC;AAOD,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,YAAoB;IAK5D,MAAM,OAAO,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;IACjE,MAAM,MAAM,GAAuB,EAAE,CAAC;IACtC,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAqB,CAAC;IAChE,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,MAAM,IAAI,4BAA4B,CACpC,wCAAwC;YACtC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CACnE,CAAC;IACJ,CAAC;IACD,MAAM,QAAQ,GAAG,0BAA0B,CAAC,MAAM,CAAC,CAAC;IACpD,OAAO;QACL,MAAM;QACN,SAAS,EAAE,QAAQ,CAAC,aAAa;QACjC,eAAe,EAAE,QAAQ,CAAC,mBAAmB;KAC9C,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Minimatch} from 'minimatch';\nimport fs from 'fs';\nimport * as jsonc from 'jsonc-parser';\n\n/** Configuration describing how files are synced into Google. */\nexport interface GoogleSyncConfig {\n  /**\n   * Patterns matching files which are synced into Google. Patterns\n   * should be relative to the project directory.\n   */\n  syncedFilePatterns: string[];\n  /**\n   * Patterns matching files which are never synced into Google. Patterns\n   * should be relative to the project directory.\n   */\n  alwaysExternalFilePatterns: string[];\n  /**\n   * Patterns matching files which need to be synced separately.\n   * Patterns should be relative to the project directory.\n   */\n  separateFilePatterns: string[];\n}\n\n/** Describes a function for testing if a file is synced. */\nexport type SyncFileMatchFn = (projectRelativePath: string) => boolean;\n\n/** Error class used when the Google Sync configuration is invalid. */\nexport class InvalidGoogleSyncConfigError extends Error {}\n\n/** Transforms the given sync configuration into a file match function. */\nexport function transformConfigIntoMatcher(config: GoogleSyncConfig): {\n  ngSyncMatchFn: SyncFileMatchFn;\n  separateSyncMatchFn: SyncFileMatchFn;\n} {\n  const syncedFilePatterns = config.syncedFilePatterns.map((p) => new Minimatch(p));\n  const alwaysExternalFilePatterns = config.alwaysExternalFilePatterns.map((p) => new Minimatch(p));\n  const separateFilePatterns = config.separateFilePatterns.map((p) => new Minimatch(p));\n\n  // match everything that needs to be synced except external and separate sync files\n  const ngSyncMatchFn = (projectRelativePath: string) =>\n    syncedFilePatterns.some((p) => p.match(projectRelativePath)) &&\n    alwaysExternalFilePatterns.every((p) => !p.match(projectRelativePath)) &&\n    separateFilePatterns.every((p) => !p.match(projectRelativePath));\n\n  // match only files that need to be synced separately\n  const separateSyncMatchFn = (projectRelativePath: string) =>\n    separateFilePatterns.some((p) => p.match(projectRelativePath)) &&\n    alwaysExternalFilePatterns.every((p) => !p.match(projectRelativePath));\n\n  return {ngSyncMatchFn, separateSyncMatchFn};\n}\n\n/**\n * Reads the configuration file from the given path.\n *\n * @throws {InvalidGoogleSyncConfigError} If the configuration is invalid.\n */\nexport async function getGoogleSyncConfig(absolutePath: string): Promise<{\n  ngMatchFn: SyncFileMatchFn;\n  separateMatchFn: SyncFileMatchFn;\n  config: GoogleSyncConfig;\n}> {\n  const content = await fs.promises.readFile(absolutePath, 'utf8');\n  const errors: jsonc.ParseError[] = [];\n  const config = jsonc.parse(content, errors) as GoogleSyncConfig;\n  if (errors.length !== 0) {\n    throw new InvalidGoogleSyncConfigError(\n      `Google Sync Configuration is invalid: ` +\n        errors.map((e) => jsonc.printParseErrorCode(e.error)).join('\\n'),\n    );\n  }\n  const matchFns = transformConfigIntoMatcher(config);\n  return {\n    config,\n    ngMatchFn: matchFns.ngSyncMatchFn,\n    separateMatchFn: matchFns.separateSyncMatchFn,\n  };\n}\n"]}