{"version":3,"file":"config.js","sourceRoot":"","sources":["config.ts"],"names":[],"mappings":"AAQA,OAAO,EAAC,IAAI,EAAC,MAAM,MAAM,CAAC;AAC1B,OAAO,IAAI,MAAM,WAAW,CAAC;AAC7B,OAAO,EAAC,QAAQ,EAAC,MAAM,aAAa,CAAC;AAErC,OAAO,EAAC,GAAG,EAAC,MAAM,cAAc,CAAC;AACjC,OAAO,EAAC,eAAe,EAAE,eAAe,EAAC,MAAM,mBAAmB,CAAC;AACnE,OAAO,EAAC,2BAA2B,EAAC,MAAM,qBAAqB,CAAC;AAChE,OAAO,EAAC,aAAa,EAAC,MAAM,KAAK,CAAC;AAqElC,MAAM,wBAAwB,GAAG,0BAA0B,CAAC;AAM5D,MAAM,qBAAqB,GAAG,cAAc,CAAC;AAG7C,IAAI,UAAU,GAAgC,IAAI,CAAC;AAMnD,MAAM,CAAC,MAAM,SAAS,GAAG,eAAe,CAAC;AAWzC,MAAM,CAAC,KAAK,UAAU,SAAS,CAAC,mBAA6B;IAC3D,IAAI,YAAY,GAAG,eAAe,EAAE,CAAC;IAErC,IAAI,YAAY,KAAK,IAAI,EAAE,CAAC;QAC1B,IAAI,OAAe,CAAC;QACpB,IAAI,OAAO,mBAAmB,KAAK,QAAQ,EAAE,CAAC;YAC5C,OAAO,GAAG,mBAAmB,CAAC;QAChC,CAAC;aAAM,CAAC;YACN,OAAO,GAAG,2BAA2B,EAAE,CAAC;QAC1C,CAAC;QAGD,MAAM,CAAC,WAAW,CAAC,GAAG,MAAM,IAAI,CAAC,wBAAwB,EAAE,EAAC,GAAG,EAAE,OAAO,EAAC,CAAC,CAAC;QAI3E,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QAE9C,YAAY,GAAG,MAAM,cAAc,CAAC,UAAU,CAAC,CAAC;QAGhD,eAAe,CAAC,YAAY,CAAC,CAAC;IAChC,CAAC;IAED,IAAI,KAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE,CAAC;QACvC,KAAK,MAAM,SAAS,IAAI,mBAAmB,EAAE,CAAC;YAC5C,SAAS,CAAC,YAAY,CAAC,CAAC;QAC1B,CAAC;IACH,CAAC;IAID,OAAO,EAAC,GAAG,YAAY,EAAE,qBAAqB,EAAE,IAAI,EAAC,CAAC;AACxD,CAAC;AASD,MAAM,CAAC,KAAK,UAAU,aAAa;IAEjC,IAAI,UAAU,KAAK,IAAI,EAAE,CAAC;QAExB,MAAM,UAAU,GAAG,IAAI,CAAC,2BAA2B,EAAE,EAAE,qBAAqB,CAAC,CAAC;QAE9E,UAAU,GAAG,MAAM,cAAc,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;IACtD,CAAC;IAGD,OAAO,EAAC,GAAG,UAAU,EAAC,CAAC;AACzB,CAAC;AAGD,MAAM,OAAO,qBAAsB,SAAQ,KAAK;IAC9C,YACE,OAAgB,EACA,SAAmB,EAAE;QAErC,KAAK,CAAC,OAAO,CAAC,CAAC;QAFC,WAAM,GAAN,MAAM,CAAe;IAGvC,CAAC;CACF;AAGD,MAAM,UAAU,uBAAuB,CACrC,MAA2C;IAE3C,MAAM,MAAM,GAAa,EAAE,CAAC;IAE5B,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;QAChC,MAAM,CAAC,IAAI,CAAC,4DAA4D,CAAC,CAAC;IAC5E,CAAC;SAAM,CAAC;QACN,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YACrC,MAAM,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;QAC9C,CAAC;QACD,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YACtC,MAAM,CAAC,IAAI,CAAC,+BAA+B,CAAC,CAAC;QAC/C,CAAC;IACH,CAAC;IACD,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;QAClB,MAAM,IAAI,qBAAqB,CAAC,gCAAgC,EAAE,MAAM,CAAC,CAAC;IAC5E,CAAC;AACH,CAAC;AAGD,MAAM,UAAU,0BAA0B,CACxC,MAAiD;IAEjD,IAAI,MAAM,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;QACnC,MAAM,IAAI,qBAAqB,CAAC,0CAA0C,CAAC,CAAC;IAC9E,CAAC;AACH,CAAC;AAMD,KAAK,UAAU,cAAc,CAAC,UAAkB,EAAE,wBAAwB,GAAG,KAAK;IAChF,MAAM,UAAU,GAAG,QAAQ,CAAC,EAAC,QAAQ,EAAE,KAAK,EAAC,CAAC,CAAC;IAC/C,IAAI,CAAC;QAGH,OAAO,MAAM,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC5D,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACX,IAAI,wBAAwB,EAAE,CAAC;YAC7B,GAAG,CAAC,KAAK,CACP,wCAAwC,UAAU,mCAAmC,CACtF,CAAC;YACF,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACb,OAAO,EAAE,CAAC;QACZ,CAAC;QACD,GAAG,CAAC,KAAK,CAAC,wCAAwC,UAAU,GAAG,CAAC,CAAC;QACjE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACb,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;YAAS,CAAC;QACT,UAAU,EAAE,CAAC;IACf,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {join} from 'path';\nimport glob from 'fast-glob';\nimport {register} from 'tsx/esm/api';\nimport {Assertions, MultipleAssertions} from './config-assertions.js';\nimport {Log} from './logging.js';\nimport {getCachedConfig, setCachedConfig} from './config-cache.js';\nimport {determineRepoBaseDirFromCwd} from './repo-directory.js';\nimport {pathToFileURL} from 'url';\n\n/**\n * Type describing a ng-dev configuration.\n *\n * This is a branded type to ensure that we can safely assert an object\n * being a config object instead of it being e.g. a `Promise` object.\n */\nexport type NgDevConfig<T = {}> = T & {\n  __isNgDevConfigObject: boolean;\n};\n\n/**\n * Describes the Github configuration for dev-infra. This configuration is\n * used for API requests, determining the upstream remote, etc.\n */\nexport interface GithubConfig {\n  /** Owner name of the repository. */\n  owner: string;\n  /** Name of the repository. */\n  name: string;\n  /** Main branch name for the repository. */\n  mainBranchName: string;\n  /** If SSH protocol should be used for git interactions. */\n  useSsh?: boolean;\n  /** Whether the specified repository is private. */\n  private?: boolean;\n  /** Whether to default to use NgDevService for authentication. */\n  useNgDevAuthService?: boolean;\n}\n\n/** Configuration describing how files are synced into Google. */\nexport interface GoogleSyncConfig {\n  /**\n   * Patterns matching files which are synced into Google. Patterns\n   * should be relative to the project directory.\n   */\n  syncedFilePatterns: string[];\n  /**\n   * Patterns matching files which are never synced into Google. Patterns\n   * should be relative to the project directory.\n   */\n  alwaysExternalFilePatterns: string[];\n  /**\n   * Patterns matching files which need to be synced separately.\n   * Patterns should be relative to the project directory.\n   */\n  separateFilePatterns: string[];\n}\n\nexport interface CaretakerConfig {\n  /** Github queries showing a snapshot of pulls/issues caretakers need to monitor. */\n  githubQueries?: {name: string; query: string}[];\n  /**\n   * The Github group used to track current caretakers. A second group is assumed to exist with the\n   * name \"<group-name>-roster\" containing a list of all users eligible for the caretaker group.\n   * */\n  caretakerGroup?: string;\n  /**\n   * Project-relative path to a config file describing how the project is synced into Google.\n   * The configuration file is expected to be valid JSONC and match {@see GoogleSyncConfig}.\n   */\n  g3SyncConfigPath?: string;\n}\n\n/**\n * The filename expected for creating the ng-dev config, without the file\n * extension to allow either a typescript or javascript file to be used.\n */\nconst CONFIG_FILE_PATH_MATCHER = '.ng-dev/config.{mjs,mts}';\n\n/**\n * The filename expected for local user config, without the file extension to allow a typescript,\n * javascript or json file to be used.\n */\nconst USER_CONFIG_FILE_PATH = '.ng-dev.user';\n\n/** The local user configuration for ng-dev. */\nlet userConfig: {[key: string]: any} | null = null;\n\n/**\n * Set the cached configuration object to be loaded later. Only to be used on\n * CI and test situations in which loading from the `.ng-dev/` directory is not possible.\n */\nexport const setConfig = setCachedConfig;\n\n/**\n * Get the configuration from the file system, returning the already loaded\n * copy if it is defined.\n */\nexport async function getConfig(): Promise<NgDevConfig>;\nexport async function getConfig(baseDir: string): Promise<NgDevConfig>;\nexport async function getConfig<A extends MultipleAssertions>(\n  assertions: A,\n): Promise<NgDevConfig<Assertions<A>>>;\nexport async function getConfig(baseDirOrAssertions?: unknown) {\n  let cachedConfig = getCachedConfig();\n\n  if (cachedConfig === null) {\n    let baseDir: string;\n    if (typeof baseDirOrAssertions === 'string') {\n      baseDir = baseDirOrAssertions;\n    } else {\n      baseDir = determineRepoBaseDirFromCwd();\n    }\n\n    /** The configuration file discovered based on a glob match. */\n    const [matchedFile] = await glob(CONFIG_FILE_PATH_MATCHER, {cwd: baseDir});\n\n    // If the global config is not defined, load it from the file system.\n    // The full path to the configuration file.\n    const configPath = join(baseDir, matchedFile);\n    // Read the configuration and validate it before caching it for the future.\n    cachedConfig = await readConfigFile(configPath);\n\n    // Store the newly-read configuration in the cache.\n    setCachedConfig(cachedConfig);\n  }\n\n  if (Array.isArray(baseDirOrAssertions)) {\n    for (const assertion of baseDirOrAssertions) {\n      assertion(cachedConfig);\n    }\n  }\n\n  // Return a clone of the cached global config to ensure that a new instance of the config\n  // is returned each time, preventing unexpected effects of modifications to the config object.\n  return {...cachedConfig, __isNgDevConfigObject: true};\n}\n\n/**\n * Get the local user configuration from the file system, returning the already loaded copy if it is\n * defined.\n *\n * @returns The user configuration object, or an empty object if no user configuration file is\n * present. The object is an untyped object as there are no required user configurations.\n */\nexport async function getUserConfig() {\n  // If the global config is not defined, load it from the file system.\n  if (userConfig === null) {\n    // The full path to the configuration file.\n    const configPath = join(determineRepoBaseDirFromCwd(), USER_CONFIG_FILE_PATH);\n    // Set the global config object.\n    userConfig = await readConfigFile(configPath, true);\n  }\n  // Return a clone of the user config to ensure that a new instance of the config is returned\n  // each time, preventing unexpected effects of modifications to the config object.\n  return {...userConfig};\n}\n\n/** A standard error class to thrown during assertions while validating configuration. */\nexport class ConfigValidationError extends Error {\n  constructor(\n    message?: string,\n    public readonly errors: string[] = [],\n  ) {\n    super(message);\n  }\n}\n\n/** Validate th configuration has been met for the ng-dev command. */\nexport function assertValidGithubConfig<T extends NgDevConfig>(\n  config: T & Partial<{github: GithubConfig}>,\n): asserts config is T & {github: GithubConfig} {\n  const errors: string[] = [];\n  // Validate the github configuration.\n  if (config.github === undefined) {\n    errors.push(`Github repository not configured. Set the \"github\" option.`);\n  } else {\n    if (config.github.name === undefined) {\n      errors.push(`\"github.name\" is not defined`);\n    }\n    if (config.github.owner === undefined) {\n      errors.push(`\"github.owner\" is not defined`);\n    }\n  }\n  if (errors.length) {\n    throw new ConfigValidationError('Invalid `github` configuration', errors);\n  }\n}\n\n/** Retrieve and validate the config as `CaretakerConfig`. */\nexport function assertValidCaretakerConfig<T extends NgDevConfig>(\n  config: T & Partial<{caretaker: CaretakerConfig}>,\n): asserts config is T & {caretaker: CaretakerConfig} {\n  if (config.caretaker === undefined) {\n    throw new ConfigValidationError(`No configuration defined for \"caretaker\"`);\n  }\n}\n\n/**\n * Resolves and reads the specified configuration file, optionally returning an empty object\n * if the configuration file cannot be read.\n */\nasync function readConfigFile(configPath: string, returnEmptyObjectOnError = false): Promise<{}> {\n  const unregister = register({tsconfig: false});\n  try {\n    // ESM imports expect a valid URL. On Windows, the disk name causes errors like:\n    // `ERR_UNSUPPORTED_ESM_URL_SCHEME: <..> Received protocol 'c:'`\n    return await import(pathToFileURL(configPath).toString());\n  } catch (e) {\n    if (returnEmptyObjectOnError) {\n      Log.debug(\n        `Could not read configuration file at ${configPath}, returning empty object instead.`,\n      );\n      Log.debug(e);\n      return {};\n    }\n    Log.error(`Could not read configuration file at ${configPath}.`);\n    Log.error(e);\n    process.exit(1);\n  } finally {\n    unregister();\n  }\n}\n"]}