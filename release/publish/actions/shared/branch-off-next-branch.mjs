/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import semver from 'semver';
import { green, Log } from '../../../../utils/logging.js';
import { workspaceRelativePackageJsonPath } from '../../../../utils/constants.js';
import { workspaceRelativeChangelogPath } from '../../../notes/release-notes.js';
import { getCommitMessageForExceptionalNextVersionBump, getReleaseNoteCherryPickCommitMessage, } from '../../commit-message.js';
import { CutNpmNextPrereleaseAction } from '../cut-npm-next-prerelease.js';
import { CutNpmNextReleaseCandidateAction } from '../cut-npm-next-release-candidate.js';
import { ActiveReleaseTrains } from '../../../versioning/active-release-trains.js';
/**
 * Base action that can be used to move the next release-train into the dedicated FF/RC
 * release-train while also cutting a release to move the train into the `feature-freeze`
 * or `release-candidate` phase.
 *
 * This means that a new version branch is created based on the next branch, and a new
 * pre-release (either RC or another `next`) is cut- indicating the new phase.
 */
export class BranchOffNextBranchBaseAction extends CutNpmNextPrereleaseAction {
    constructor() {
        super(...arguments);
        // Instances of the action for cutting a NPM next pre-releases. We will re-use
        // these for determining the "new versions" and "release notes comparison version".
        // This helps avoiding duplication, especially since there are is some special logic.
        this._nextPrerelease = new CutNpmNextPrereleaseAction(new ActiveReleaseTrains({ ...this.active, releaseCandidate: null }), this.git, this.config, this.projectDir);
        this._rcPrerelease = new CutNpmNextReleaseCandidateAction(new ActiveReleaseTrains({ ...this.active, releaseCandidate: this.active.next }), this.git, this.config, this.projectDir);
    }
    async getDescription() {
        const { branchName } = this.active.next;
        const newVersion = await this._computeNewVersion();
        return `Move the "${branchName}" branch into ${this.newPhaseName} phase (v${newVersion}).`;
    }
    async perform() {
        const nextBranchName = this.active.next.branchName;
        const compareVersionForReleaseNotes = await this._computeReleaseNoteCompareVersion();
        const newVersion = await this._computeNewVersion();
        const newBranch = `${newVersion.major}.${newVersion.minor}.x`;
        const beforeStagingSha = await this.getLatestCommitOfBranch(nextBranchName);
        // Verify the current next branch has a passing status, before we branch off.
        await this.assertPassingGithubStatus(beforeStagingSha, nextBranchName);
        // Branch-off the next branch into a new version branch.
        await this._createNewVersionBranchFromNext(newBranch);
        // Stage the new version for the newly created branch, and push changes to a
        // fork in order to create a staging pull request. Note that we re-use the newly
        // created branch instead of re-fetching from the upstream.
        const { pullRequest, releaseNotes, builtPackagesWithInfo } = await this.stageVersionForBranchAndCreatePullRequest(newVersion, compareVersionForReleaseNotes, newBranch);
        // Wait for the staging PR to be merged. Then publish the feature-freeze next pre-release. Finally,
        // cherry-pick the release notes into the next branch in combination with bumping the version to
        // the next minor too.
        await this.promptAndWaitForPullRequestMerged(pullRequest);
        await this.publish(builtPackagesWithInfo, releaseNotes, beforeStagingSha, newBranch, 'next', {
            showAsLatestOnGitHub: false,
        });
        const branchOffPullRequest = await this._createNextBranchUpdatePullRequest(releaseNotes, newVersion);
        await this.promptAndWaitForPullRequestMerged(branchOffPullRequest);
    }
    /** Computes the new version for the release-train being branched-off. */
    async _computeNewVersion() {
        if (this.newPhaseName === 'feature-freeze') {
            return this._nextPrerelease.getNewVersion();
        }
        else {
            return this._rcPrerelease.getNewVersion();
        }
    }
    /** Gets the release notes compare version for the branching-off release. */
    async _computeReleaseNoteCompareVersion() {
        // Regardless of the new phase, the release notes compare version should
        // always be the one as if a pre-release is cut on the `next` branch.
        // We cannot rely on the `CutNpmNextReleaseCandidateAction` here because it
        // assumes a published release for the train. This is not guaranteed.
        return await this._nextPrerelease.releaseNotesCompareVersion;
    }
    /** Creates a new version branch from the next branch. */
    async _createNewVersionBranchFromNext(newBranch) {
        const { branchName: nextBranch } = this.active.next;
        await this.checkoutUpstreamBranch(nextBranch);
        await this.createLocalBranchFromHead(newBranch);
        await this.pushHeadToRemoteBranch(newBranch);
        Log.info(green(`  ✓   Version branch "${newBranch}" created.`));
    }
    /**
     * Creates a pull request for the next branch that bumps the version to the next
     * minor, and cherry-picks the changelog for the newly branched-off release-candidate
     * or feature-freeze version.
     */
    async _createNextBranchUpdatePullRequest(releaseNotes, newVersion) {
        const { branchName: nextBranch, version } = this.active.next;
        // We increase the version for the next branch to the next minor. The team can decide
        // later if they want next to be a major through the `Configure Next as Major` release action.
        const newNextVersion = semver.parse(`${version.major}.${version.minor + 1}.0-next.0`);
        const bumpCommitMessage = getCommitMessageForExceptionalNextVersionBump(newNextVersion);
        await this.checkoutUpstreamBranch(nextBranch);
        await this.updateProjectVersion(newNextVersion);
        // Create an individual commit for the next version bump. The changelog should go into
        // a separate commit that makes it clear where the changelog is cherry-picked from.
        await this.createCommit(bumpCommitMessage, [workspaceRelativePackageJsonPath]);
        await this.prependReleaseNotesToChangelog(releaseNotes);
        const commitMessage = getReleaseNoteCherryPickCommitMessage(releaseNotes.version);
        await this.createCommit(commitMessage, [workspaceRelativeChangelogPath]);
        let nextPullRequestMessage = `The previous "next" release-train has moved into the ` +
            `${this.newPhaseName} phase. This PR updates the next branch to the subsequent ` +
            `release-train.\n\nAlso this PR cherry-picks the changelog for ` +
            `v${newVersion} into the ${nextBranch} branch so that the changelog is up to date.`;
        const nextUpdatePullRequest = await this.pushChangesToForkAndCreatePullRequest(nextBranch, `next-release-train-${newNextVersion}`, `Update next branch to reflect new release-train "v${newNextVersion}".`, nextPullRequestMessage);
        Log.info(green(`  ✓   Pull request for updating the "${nextBranch}" branch has been created.`));
        return nextUpdatePullRequest;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJhbmNoLW9mZi1uZXh0LWJyYW5jaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9yZWxlYXNlL3B1Ymxpc2gvYWN0aW9ucy9zaGFyZWQvYnJhbmNoLW9mZi1uZXh0LWJyYW5jaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFFNUIsT0FBTyxFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUN4RCxPQUFPLEVBQUMsZ0NBQWdDLEVBQUMsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNoRixPQUFPLEVBQWUsOEJBQThCLEVBQUMsTUFBTSxpQ0FBaUMsQ0FBQztBQUU3RixPQUFPLEVBQ0wsNkNBQTZDLEVBQzdDLHFDQUFxQyxHQUN0QyxNQUFNLHlCQUF5QixDQUFDO0FBQ2pDLE9BQU8sRUFBQywwQkFBMEIsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBQ3pFLE9BQU8sRUFBQyxnQ0FBZ0MsRUFBQyxNQUFNLHNDQUFzQyxDQUFDO0FBQ3RGLE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLDhDQUE4QyxDQUFDO0FBRWpGOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLE9BQWdCLDZCQUE4QixTQUFRLDBCQUEwQjtJQUF0Rjs7UUFJRSw4RUFBOEU7UUFDOUUsbUZBQW1GO1FBQ25GLHFGQUFxRjtRQUM3RSxvQkFBZSxHQUFHLElBQUksMEJBQTBCLENBQ3RELElBQUksbUJBQW1CLENBQUMsRUFBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFDLENBQUMsRUFDakUsSUFBSSxDQUFDLEdBQUcsRUFDUixJQUFJLENBQUMsTUFBTSxFQUNYLElBQUksQ0FBQyxVQUFVLENBQ2hCLENBQUM7UUFDTSxrQkFBYSxHQUFHLElBQUksZ0NBQWdDLENBQzFELElBQUksbUJBQW1CLENBQUMs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OEJBQThCLENBQUMsQ0FBQyxDQUFDO1FBRXpFLElBQUksc0JBQXNCLEdBQ3hCLHVEQUF1RDtZQUN2RCxHQUFHLElBQUksQ0FBQyxZQUFZLDREQUE0RDtZQUNoRixnRUFBZ0U7WUFDaEUsSUFBSSxVQUFVLGFBQWEsVUFBVSw4Q0FBOEMsQ0FBQztRQUV0RixNQUFNLHFCQUFxQixHQUFHLE1BQU0sSUFBSSxDQUFDLHFDQUFxQyxDQUM1RSxVQUFVLEVBQ1Ysc0JBQXNCLGNBQWMsRUFBRSxFQUN0QyxxREFBcUQsY0FBYyxJQUFJLEVBQ3ZFLHNCQUFzQixDQUN2QixDQUFDO1FBRUYsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsd0NBQXdDLFVBQVUsNEJBQTRCLENBQUMsQ0FBQyxDQUFDO1FBRWhHLE9BQU8scUJBQXFCLENBQUM7SUFDL0IsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuaW1wb3J0IHtncmVlbiwgTG9nfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nLmpzJztcbmltcG9ydCB7d29ya3NwYWNlUmVsYXRpdmVQYWNrYWdlSnNvblBhdGh9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1JlbGVhc2VOb3Rlcywgd29ya3NwYWNlUmVsYXRpdmVDaGFuZ2Vsb2dQYXRofSBmcm9tICcuLi8uLi8uLi9ub3Rlcy9yZWxlYXNlLW5vdGVzLmpzJztcbmltcG9ydCB7UHVsbFJlcXVlc3R9IGZyb20gJy4uLy4uL2FjdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgZ2V0Q29tbWl0TWVzc2FnZUZvckV4Y2VwdGlvbmFsTmV4dFZlcnNpb25CdW1wLFxuICBnZXRSZWxlYXNlTm90ZUNoZXJyeVBpY2tDb21taXRNZXNzYWdlLFxufSBmcm9tICcuLi8uLi9jb21taXQtbWVzc2FnZS5qcyc7XG5pbXBvcnQge0N1dE5wbU5leHRQcmVyZWxlYXNlQWN0aW9ufSBmcm9tICcuLi9jdXQtbnBtLW5leHQtcHJlcmVsZWFzZS5qcyc7XG5pbXBvcnQge0N1dE5wbU5leHRSZWxlYXNlQ2FuZGlkYXRlQWN0aW9ufSBmcm9tICcuLi9jdXQtbnBtLW5leHQtcmVsZWFzZS1jYW5kaWRhdGUuanMnO1xuaW1wb3J0IHtBY3RpdmVSZWxlYXNlVHJhaW5zfSBmcm9tICcuLi8uLi8uLi92ZXJzaW9uaW5nL2FjdGl2ZS1yZWxlYXNlLXRyYWlucy5qcyc7XG5cbi8qKlxuICogQmFzZSBhY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBtb3ZlIHRoZSBuZXh0IHJlbGVhc2UtdHJhaW4gaW50byB0aGUgZGVkaWNhdGVkIEZGL1JDXG4gKiByZWxlYXNlLXRyYWluIHdoaWxlIGFsc28gY3V0dGluZyBhIHJlbGVhc2UgdG8gbW92ZSB0aGUgdHJhaW4gaW50byB0aGUgYGZlYXR1cmUtZnJlZXplYFxuICogb3IgYHJlbGVhc2UtY2FuZGlkYXRlYCBwaGFzZS5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgYSBuZXcgdmVyc2lvbiBicmFuY2ggaXMgY3JlYXRlZCBiYXNlZCBvbiB0aGUgbmV4dCBicmFuY2gsIGFuZCBhIG5ld1xuICogcHJlLXJlbGVhc2UgKGVpdGhlciBSQyBvciBhbm90aGVyIGBuZXh0YCkgaXMgY3V0LSBpbmRpY2F0aW5nIHRoZSBuZXcgcGhhc2UuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCcmFuY2hPZmZOZXh0QnJhbmNoQmFzZUFjdGlvbiBleHRlbmRzIEN1dE5wbU5leHRQcmVyZWxlYXNlQWN0aW9uIHtcbiAgLyoqIFBoYXNlIHdoaWNoIHRoZSByZWxlYXNlLXRyYWluIGN1cnJlbnRseSBpbiB0aGUgYG5leHRgIHBoYXNlIHdpbGwgbW92ZSBpbnRvLiAqL1xuICBhYnN0cmFjdCBuZXdQaGFzZU5hbWU6ICdmZWF0dXJlLWZyZWV6ZScgfCAncmVsZWFzZS1jYW5kaWRhdGUnO1xuXG4gIC8vIEluc3RhbmNlcyBvZiB0aGUgYWN0aW9uIGZvciBjdXR0aW5nIGEgTlBNIG5leHQgcHJlLXJlbGVhc2VzLiBXZSB3aWxsIHJlLXVzZVxuICAvLyB0aGVzZSBmb3IgZGV0ZXJtaW5pbmcgdGhlIFwibmV3IHZlcnNpb25zXCIgYW5kIFwicmVsZWFzZSBub3RlcyBjb21wYXJpc29uIHZlcnNpb25cIi5cbiAgLy8gVGhpcyBoZWxwcyBhdm9pZGluZyBkdXBsaWNhdGlvbiwgZXNwZWNpYWxseSBzaW5jZSB0aGVyZSBhcmUgaXMgc29tZSBzcGVjaWFsIGxvZ2ljLlxuICBwcml2YXRlIF9uZXh0UHJlcmVsZWFzZSA9IG5ldyBDdXROcG1OZXh0UHJlcmVsZWFzZUFjdGlvbihcbiAgICBuZXcgQWN0aXZlUmVsZWFzZVRyYWlucyh7Li4udGhpcy5hY3RpdmUsIHJlbGVhc2VDYW5kaWRhdGU6IG51bGx9KSxcbiAgICB0aGlzLmdpdCxcbiAgICB0aGlzLmNvbmZpZyxcbiAgICB0aGlzLnByb2plY3REaXIsXG4gICk7XG4gIHByaXZhdGUgX3JjUHJlcmVsZWFzZSA9IG5ldyBDdXROcG1OZXh0UmVsZWFzZUNhbmRpZGF0ZUFjdGlvbihcbiAgICBuZXcgQWN0aXZlUmVsZWFzZVRyYWlucyh7Li4udGhpcy5hY3RpdmUsIHJlbGVhc2VDYW5kaWRhdGU6IHRoaXMuYWN0aXZlLm5leHR9KSxcbiAgICB0aGlzLmdpdCxcbiAgICB0aGlzLmNvbmZpZyxcbiAgICB0aGlzLnByb2plY3REaXIsXG4gICk7XG5cbiAgb3ZlcnJpZGUgYXN5bmMgZ2V0RGVzY3JpcHRpb24oKSB7XG4gICAgY29uc3Qge2JyYW5jaE5hbWV9ID0gdGhpcy5hY3RpdmUubmV4dDtcbiAgICBjb25zdCBuZXdWZXJzaW9uID0gYXdhaXQgdGhpcy5fY29tcHV0ZU5ld1ZlcnNpb24oKTtcbiAgICByZXR1cm4gYE1vdmUgdGhlIFwiJHticmFuY2hOYW1lfVwiIGJyYW5jaCBpbnRvICR7dGhpcy5uZXdQaGFzZU5hbWV9IHBoYXNlICh2JHtuZXdWZXJzaW9ufSkuYDtcbiAgfVxuXG4gIG92ZXJyaWRlIGFzeW5jIHBlcmZvcm0oKSB7XG4gICAgY29uc3QgbmV4dEJyYW5jaE5hbWUgPSB0aGlzLmFjdGl2ZS5uZXh0LmJyYW5jaE5hbWU7XG4gICAgY29uc3QgY29tcGFyZVZlcnNpb25Gb3JSZWxlYXNlTm90ZXMgPSBhd2FpdCB0aGlzLl9jb21wdXRlUmVsZWFzZU5vdGVDb21wYXJlVmVyc2lvbigpO1xuICAgIGNvbnN0IG5ld1ZlcnNpb24gPSBhd2FpdCB0aGlzLl9jb21wdXRlTmV3VmVyc2lvbigpO1xuICAgIGNvbnN0IG5ld0JyYW5jaCA9IGAke25ld1ZlcnNpb24ubWFqb3J9LiR7bmV3VmVyc2lvbi5taW5vcn0ueGA7XG4gICAgY29uc3QgYmVmb3JlU3RhZ2luZ1NoYSA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0Q29tbWl0T2ZCcmFuY2gobmV4dEJyYW5jaE5hbWUpO1xuXG4gICAgLy8gVmVyaWZ5IHRoZSBjdXJyZW50IG5leHQgYnJhbmNoIGhhcyBhIHBhc3Npbmcgc3RhdHVzLCBiZWZvcmUgd2UgYnJhbmNoIG9mZi5cbiAgICBhd2FpdCB0aGlzLmFzc2VydFBhc3NpbmdHaXRodWJTdGF0dXMoYmVmb3JlU3RhZ2luZ1NoYSwgbmV4dEJyYW5jaE5hbWUpO1xuXG4gICAgLy8gQnJhbmNoLW9mZiB0aGUgbmV4dCBicmFuY2ggaW50byBhIG5ldyB2ZXJzaW9uIGJyYW5jaC5cbiAgICBhd2FpdCB0aGlzLl9jcmVhdGVOZXdWZXJzaW9uQnJhbmNoRnJvbU5leHQobmV3QnJhbmNoKTtcblxuICAgIC8vIFN0YWdlIHRoZSBuZXcgdmVyc2lvbiBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgYnJhbmNoLCBhbmQgcHVzaCBjaGFuZ2VzIHRvIGFcbiAgICAvLyBmb3JrIGluIG9yZGVyIHRvIGNyZWF0ZSBhIHN0YWdpbmcgcHVsbCByZXF1ZXN0LiBOb3RlIHRoYXQgd2UgcmUtdXNlIHRoZSBuZXdseVxuICAgIC8vIGNyZWF0ZWQgYnJhbmNoIGluc3RlYWQgb2YgcmUtZmV0Y2hpbmcgZnJvbSB0aGUgdXBzdHJlYW0uXG4gICAgY29uc3Qge3B1bGxSZXF1ZXN0LCByZWxlYXNlTm90ZXMsIGJ1aWx0UGFja2FnZXNXaXRoSW5mb30gPVxuICAgICAgYXdhaXQgdGhpcy5zdGFnZVZlcnNpb25Gb3JCcmFuY2hBbmRDcmVhdGVQdWxsUmVxdWVzdChcbiAgICAgICAgbmV3VmVyc2lvbixcbiAgICAgICAgY29tcGFyZVZlcnNpb25Gb3JSZWxlYXNlTm90ZXMsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICk7XG5cbiAgICAvLyBXYWl0IGZvciB0aGUgc3RhZ2luZyBQUiB0byBiZSBtZXJnZWQuIFRoZW4gcHVibGlzaCB0aGUgZmVhdHVyZS1mcmVlemUgbmV4dCBwcmUtcmVsZWFzZS4gRmluYWxseSxcbiAgICAvLyBjaGVycnktcGljayB0aGUgcmVsZWFzZSBub3RlcyBpbnRvIHRoZSBuZXh0IGJyYW5jaCBpbiBjb21iaW5hdGlvbiB3aXRoIGJ1bXBpbmcgdGhlIHZlcnNpb24gdG9cbiAgICAvLyB0aGUgbmV4dCBtaW5vciB0b28uXG4gICAgYXdhaXQgdGhpcy5wcm9tcHRBbmRXYWl0Rm9yUHVsbFJlcXVlc3RNZXJnZWQocHVsbFJlcXVlc3QpO1xuICAgIGF3YWl0IHRoaXMucHVibGlzaChidWlsdFBhY2thZ2VzV2l0aEluZm8sIHJlbGVhc2VOb3RlcywgYmVmb3JlU3RhZ2luZ1NoYSwgbmV3QnJhbmNoLCAnbmV4dCcsIHtcbiAgICAgIHNob3dBc0xhdGVzdE9uR2l0SHViOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJyYW5jaE9mZlB1bGxSZXF1ZXN0ID0gYXdhaXQgdGhpcy5fY3JlYXRlTmV4dEJyYW5jaFVwZGF0ZVB1bGxSZXF1ZXN0KFxuICAgICAgcmVsZWFzZU5vdGVzLFxuICAgICAgbmV3VmVyc2lvbixcbiAgICApO1xuICAgIGF3YWl0IHRoaXMucHJvbXB0QW5kV2FpdEZvclB1bGxSZXF1ZXN0TWVyZ2VkKGJyYW5jaE9mZlB1bGxSZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKiBDb21wdXRlcyB0aGUgbmV3IHZlcnNpb24gZm9yIHRoZSByZWxlYXNlLXRyYWluIGJlaW5nIGJyYW5jaGVkLW9mZi4gKi9cbiAgcHJpdmF0ZSBhc3luYyBfY29tcHV0ZU5ld1ZlcnNpb24oKTogUHJvbWlzZTxzZW12ZXIuU2VtVmVyPiB7XG4gICAgaWYgKHRoaXMubmV3UGhhc2VOYW1lID09PSAnZmVhdHVyZS1mcmVlemUnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmV4dFByZXJlbGVhc2UuZ2V0TmV3VmVyc2lvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmNQcmVyZWxlYXNlLmdldE5ld1ZlcnNpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKiogR2V0cyB0aGUgcmVsZWFzZSBub3RlcyBjb21wYXJlIHZlcnNpb24gZm9yIHRoZSBicmFuY2hpbmctb2ZmIHJlbGVhc2UuICovXG4gIHByaXZhdGUgYXN5bmMgX2NvbXB1dGVSZWxlYXNlTm90ZUNvbXBhcmVWZXJzaW9uKCk6IFByb21pc2U8c2VtdmVyLlNlbVZlcj4ge1xuICAgIC8vIFJlZ2FyZGxlc3Mgb2YgdGhlIG5ldyBwaGFzZSwgdGhlIHJlbGVhc2Ugbm90ZXMgY29tcGFyZSB2ZXJzaW9uIHNob3VsZFxuICAgIC8vIGFsd2F5cyBiZSB0aGUgb25lIGFzIGlmIGEgcHJlLXJlbGVhc2UgaXMgY3V0IG9uIHRoZSBgbmV4dGAgYnJhbmNoLlxuICAgIC8vIFdlIGNhbm5vdCByZWx5IG9uIHRoZSBgQ3V0TnBtTmV4dFJlbGVhc2VDYW5kaWRhdGVBY3Rpb25gIGhlcmUgYmVjYXVzZSBpdFxuICAgIC8vIGFzc3VtZXMgYSBwdWJsaXNoZWQgcmVsZWFzZSBmb3IgdGhlIHRyYWluLiBUaGlzIGlzIG5vdCBndWFyYW50ZWVkLlxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9uZXh0UHJlcmVsZWFzZS5yZWxlYXNlTm90ZXNDb21wYXJlVmVyc2lvbjtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgbmV3IHZlcnNpb24gYnJhbmNoIGZyb20gdGhlIG5leHQgYnJhbmNoLiAqL1xuICBwcml2YXRlIGFzeW5jIF9jcmVhdGVOZXdWZXJzaW9uQnJhbmNoRnJvbU5leHQobmV3QnJhbmNoOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7YnJhbmNoTmFtZTogbmV4dEJyYW5jaH0gPSB0aGlzLmFjdGl2ZS5uZXh0O1xuICAgIGF3YWl0IHRoaXMuY2hlY2tvdXRVcHN0cmVhbUJyYW5jaChuZXh0QnJhbmNoKTtcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZUxvY2FsQnJhbmNoRnJvbUhlYWQobmV3QnJhbmNoKTtcbiAgICBhd2FpdCB0aGlzLnB1c2hIZWFkVG9SZW1vdGVCcmFuY2gobmV3QnJhbmNoKTtcbiAgICBMb2cuaW5mbyhncmVlbihgICDinJMgICBWZXJzaW9uIGJyYW5jaCBcIiR7bmV3QnJhbmNofVwiIGNyZWF0ZWQuYCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwdWxsIHJlcXVlc3QgZm9yIHRoZSBuZXh0IGJyYW5jaCB0aGF0IGJ1bXBzIHRoZSB2ZXJzaW9uIHRvIHRoZSBuZXh0XG4gICAqIG1pbm9yLCBhbmQgY2hlcnJ5LXBpY2tzIHRoZSBjaGFuZ2Vsb2cgZm9yIHRoZSBuZXdseSBicmFuY2hlZC1vZmYgcmVsZWFzZS1jYW5kaWRhdGVcbiAgICogb3IgZmVhdHVyZS1mcmVlemUgdmVyc2lvbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2NyZWF0ZU5leHRCcmFuY2hVcGRhdGVQdWxsUmVxdWVzdChcbiAgICByZWxlYXNlTm90ZXM6IFJlbGVhc2VOb3RlcyxcbiAgICBuZXdWZXJzaW9uOiBzZW12ZXIuU2VtVmVyLFxuICApOiBQcm9taXNlPFB1bGxSZXF1ZXN0PiB7XG4gICAgY29uc3Qge2JyYW5jaE5hbWU6IG5leHRCcmFuY2gsIHZlcnNpb259ID0gdGhpcy5hY3RpdmUubmV4dDtcbiAgICAvLyBXZSBpbmNyZWFzZSB0aGUgdmVyc2lvbiBmb3IgdGhlIG5leHQgYnJhbmNoIHRvIHRoZSBuZXh0IG1pbm9yLiBUaGUgdGVhbSBjYW4gZGVjaWRlXG4gICAgLy8gbGF0ZXIgaWYgdGhleSB3YW50IG5leHQgdG8gYmUgYSBtYWpvciB0aHJvdWdoIHRoZSBgQ29uZmlndXJlIE5leHQgYXMgTWFqb3JgIHJlbGVhc2UgYWN0aW9uLlxuICAgIGNvbnN0IG5ld05leHRWZXJzaW9uID0gc2VtdmVyLnBhcnNlKGAke3ZlcnNpb24ubWFqb3J9LiR7dmVyc2lvbi5taW5vciArIDF9LjAtbmV4dC4wYCkhO1xuICAgIGNvbnN0IGJ1bXBDb21taXRNZXNzYWdlID0gZ2V0Q29tbWl0TWVzc2FnZUZvckV4Y2VwdGlvbmFsTmV4dFZlcnNpb25CdW1wKG5ld05leHRWZXJzaW9uKTtcblxuICAgIGF3YWl0IHRoaXMuY2hlY2tvdXRVcHN0cmVhbUJyYW5jaChuZXh0QnJhbmNoKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVByb2plY3RWZXJzaW9uKG5ld05leHRWZXJzaW9uKTtcblxuICAgIC8vIENyZWF0ZSBhbiBpbmRpdmlkdWFsIGNvbW1pdCBmb3IgdGhlIG5leHQgdmVyc2lvbiBidW1wLiBUaGUgY2hhbmdlbG9nIHNob3VsZCBnbyBpbnRvXG4gICAgLy8gYSBzZXBhcmF0ZSBjb21taXQgdGhhdCBtYWtlcyBpdCBjbGVhciB3aGVyZSB0aGUgY2hhbmdlbG9nIGlzIGNoZXJyeS1waWNrZWQgZnJvbS5cbiAgICBhd2FpdCB0aGlzLmNyZWF0ZUNvbW1pdChidW1wQ29tbWl0TWVzc2FnZSwgW3dvcmtzcGFjZVJlbGF0aXZlUGFja2FnZUpzb25QYXRoXSk7XG5cbiAgICBhd2FpdCB0aGlzLnByZXBlbmRSZWxlYXNlTm90ZXNUb0NoYW5nZWxvZyhyZWxlYXNlTm90ZXMpO1xuXG4gICAgY29uc3QgY29tbWl0TWVzc2FnZSA9IGdldFJlbGVhc2VOb3RlQ2hlcnJ5UGlja0NvbW1pdE1lc3NhZ2UocmVsZWFzZU5vdGVzLnZlcnNpb24pO1xuXG4gICAgYXdhaXQgdGhpcy5jcmVhdGVDb21taXQoY29tbWl0TWVzc2FnZSwgW3dvcmtzcGFjZVJlbGF0aXZlQ2hhbmdlbG9nUGF0aF0pO1xuXG4gICAgbGV0IG5leHRQdWxsUmVxdWVzdE1lc3NhZ2UgPVxuICAgICAgYFRoZSBwcmV2aW91cyBcIm5leHRcIiByZWxlYXNlLXRyYWluIGhhcyBtb3ZlZCBpbnRvIHRoZSBgICtcbiAgICAgIGAke3RoaXMubmV3UGhhc2VOYW1lfSBwaGFzZS4gVGhpcyBQUiB1cGRhdGVzIHRoZSBuZXh0IGJyYW5jaCB0byB0aGUgc3Vic2VxdWVudCBgICtcbiAgICAgIGByZWxlYXNlLXRyYWluLlxcblxcbkFsc28gdGhpcyBQUiBjaGVycnktcGlja3MgdGhlIGNoYW5nZWxvZyBmb3IgYCArXG4gICAgICBgdiR7bmV3VmVyc2lvbn0gaW50byB0aGUgJHtuZXh0QnJhbmNofSBicmFuY2ggc28gdGhhdCB0aGUgY2hhbmdlbG9nIGlzIHVwIHRvIGRhdGUuYDtcblxuICAgIGNvbnN0IG5leHRVcGRhdGVQdWxsUmVxdWVzdCA9IGF3YWl0IHRoaXMucHVzaENoYW5nZXNUb0ZvcmtBbmRDcmVhdGVQdWxsUmVxdWVzdChcbiAgICAgIG5leHRCcmFuY2gsXG4gICAgICBgbmV4dC1yZWxlYXNlLXRyYWluLSR7bmV3TmV4dFZlcnNpb259YCxcbiAgICAgIGBVcGRhdGUgbmV4dCBicmFuY2ggdG8gcmVmbGVjdCBuZXcgcmVsZWFzZS10cmFpbiBcInYke25ld05leHRWZXJzaW9ufVwiLmAsXG4gICAgICBuZXh0UHVsbFJlcXVlc3RNZXNzYWdlLFxuICAgICk7XG5cbiAgICBMb2cuaW5mbyhncmVlbihgICDinJMgICBQdWxsIHJlcXVlc3QgZm9yIHVwZGF0aW5nIHRoZSBcIiR7bmV4dEJyYW5jaH1cIiBicmFuY2ggaGFzIGJlZW4gY3JlYXRlZC5gKSk7XG5cbiAgICByZXR1cm4gbmV4dFVwZGF0ZVB1bGxSZXF1ZXN0O1xuICB9XG59XG4iXX0=