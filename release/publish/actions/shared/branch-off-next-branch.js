/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import semver from 'semver';
import { green, Log } from '../../../../utils/logging.js';
import { workspaceRelativePackageJsonPath } from '../../../../utils/constants.js';
import { workspaceRelativeChangelogPath } from '../../../notes/release-notes.js';
import { getCommitMessageForExceptionalNextVersionBump, getReleaseNoteCherryPickCommitMessage, } from '../../commit-message.js';
import { CutNpmNextPrereleaseAction } from '../cut-npm-next-prerelease.js';
import { CutNpmNextReleaseCandidateAction } from '../cut-npm-next-release-candidate.js';
import { ActiveReleaseTrains } from '../../../versioning/active-release-trains.js';
import { updateRenovateConfig } from '../renovate-config-updates.js';
/**
 * Base action that can be used to move the next release-train into the dedicated FF/RC
 * release-train while also cutting a release to move the train into the `feature-freeze`
 * or `release-candidate` phase.
 *
 * This means that a new version branch is created based on the next branch, and a new
 * pre-release (either RC or another `next`) is cut- indicating the new phase.
 */
export class BranchOffNextBranchBaseAction extends CutNpmNextPrereleaseAction {
    constructor() {
        super(...arguments);
        // Instances of the action for cutting a NPM next pre-releases. We will re-use
        // these for determining the "new versions" and "release notes comparison version".
        // This helps avoiding duplication, especially since there are is some special logic.
        this._nextPrerelease = new CutNpmNextPrereleaseAction(new ActiveReleaseTrains({ ...this.active, releaseCandidate: null }), this.git, this.config, this.projectDir);
        this._rcPrerelease = new CutNpmNextReleaseCandidateAction(new ActiveReleaseTrains({ ...this.active, releaseCandidate: this.active.next }), this.git, this.config, this.projectDir);
    }
    async getDescription() {
        const { branchName } = this.active.next;
        const newVersion = await this._computeNewVersion();
        return `Move the "${branchName}" branch into ${this.newPhaseName} phase (v${newVersion}).`;
    }
    async perform() {
        const nextBranchName = this.active.next.branchName;
        const compareVersionForReleaseNotes = await this._computeReleaseNoteCompareVersion();
        const newVersion = await this._computeNewVersion();
        const newBranch = `${newVersion.major}.${newVersion.minor}.x`;
        const { sha: beforeStagingSha } = await this.getLatestCommitOfBranch(nextBranchName);
        // Verify the current next branch has a passing status, before we branch off.
        await this.assertPassingGithubStatus(beforeStagingSha, nextBranchName);
        // Branch-off the next branch into a new version branch.
        await this._createNewVersionBranchFromNext(newBranch);
        // Stage the new version for the newly created branch, and push changes to a
        // fork in order to create a staging pull request. Note that we re-use the newly
        // created branch instead of re-fetching from the upstream.
        const { pullRequest, releaseNotes, builtPackagesWithInfo } = await this.stageVersionForBranchAndCreatePullRequest(newVersion, compareVersionForReleaseNotes, newBranch);
        // Wait for the staging PR to be merged. Then publish the feature-freeze next pre-release. Finally,
        // cherry-pick the release notes into the next branch in combination with bumping the version to
        // the next minor too.
        await this.promptAndWaitForPullRequestMerged(pullRequest);
        await this.publish(builtPackagesWithInfo, releaseNotes, beforeStagingSha, newBranch, 'next', {
            showAsLatestOnGitHub: false,
        });
        const branchOffPullRequest = await this._createNextBranchUpdatePullRequest(releaseNotes, newVersion);
        await this.promptAndWaitForPullRequestMerged(branchOffPullRequest);
    }
    /** Computes the new version for the release-train being branched-off. */
    async _computeNewVersion() {
        if (this.newPhaseName === 'feature-freeze') {
            return this._nextPrerelease.getNewVersion();
        }
        else {
            return this._rcPrerelease.getNewVersion();
        }
    }
    /** Gets the release notes compare version for the branching-off release. */
    async _computeReleaseNoteCompareVersion() {
        // Regardless of the new phase, the release notes compare version should
        // always be the one as if a pre-release is cut on the `next` branch.
        // We cannot rely on the `CutNpmNextReleaseCandidateAction` here because it
        // assumes a published release for the train. This is not guaranteed.
        return await this._nextPrerelease.releaseNotesCompareVersion;
    }
    /** Creates a new version branch from the next branch. */
    async _createNewVersionBranchFromNext(newBranch) {
        const { branchName: nextBranch } = this.active.next;
        await this.checkoutUpstreamBranch(nextBranch);
        await this.createLocalBranchFromHead(newBranch);
        await this.pushHeadToRemoteBranch(newBranch);
        Log.info(green(`  ✓   Version branch "${newBranch}" created.`));
    }
    /**
     * Creates a pull request for the next branch that bumps the version to the next
     * minor, and cherry-picks the changelog for the newly branched-off release-candidate
     * or feature-freeze version.
     */
    async _createNextBranchUpdatePullRequest(releaseNotes, newVersion) {
        const { branchName: nextBranch, version } = this.active.next;
        // We increase the version for the next branch to the next minor. The team can decide
        // later if they want next to be a major through the `Configure Next as Major` release action.
        const newNextVersion = semver.parse(`${version.major}.${version.minor + 1}.0-next.0`);
        const bumpCommitMessage = getCommitMessageForExceptionalNextVersionBump(newNextVersion);
        await this.checkoutUpstreamBranch(nextBranch);
        await this.updateProjectVersion(newNextVersion);
        // Create an individual commit for the next version bump. The changelog should go into
        // a separate commit that makes it clear where the changelog is cherry-picked from.
        const filesToCommit = [
            workspaceRelativePackageJsonPath,
            ...this.getAspectLockFiles(),
        ];
        const renovateConfigPath = await updateRenovateConfig(this.projectDir, nextBranch);
        if (renovateConfigPath) {
            filesToCommit.push(renovateConfigPath);
        }
        await this.createCommit(bumpCommitMessage, filesToCommit);
        await this.prependReleaseNotesToChangelog(releaseNotes);
        const commitMessage = getReleaseNoteCherryPickCommitMessage(releaseNotes.version);
        await this.createCommit(commitMessage, [workspaceRelativeChangelogPath]);
        let nextPullRequestMessage = `The previous "next" release-train has moved into the ` +
            `${this.newPhaseName} phase. This PR updates the next branch to the subsequent ` +
            `release-train.\n\nAlso this PR cherry-picks the changelog for ` +
            `v${newVersion} into the ${nextBranch} branch so that the changelog is up to date.`;
        const nextUpdatePullRequest = await this.pushChangesToForkAndCreatePullRequest(nextBranch, `next-release-train-${newNextVersion}`, `Update next branch to reflect new release-train "v${newNextVersion}".`, nextPullRequestMessage);
        Log.info(green(`  ✓   Pull request for updating the "${nextBranch}" branch has been created.`));
        return nextUpdatePullRequest;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJhbmNoLW9mZi1uZXh0LWJyYW5jaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9yZWxlYXNlL3B1Ymxpc2gvYWN0aW9ucy9zaGFyZWQvYnJhbmNoLW9mZi1uZXh0LWJyYW5jaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFFNUIsT0FBTyxFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUN4RCxPQUFPLEVBQUMsZ0NBQWdDLEVBQUMsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNoRixPQUFPLEVBQWUsOEJBQThCLEVBQUMsTUFBTSxpQ0FBaUMsQ0FBQztBQUU3RixPQUFPLEVBQ0wsNkNBQTZDLEVBQzdDLHFDQUFxQyxHQUN0QyxNQUFNLHlCQUF5QixDQUFDO0FBQ2pDLE9BQU8sRUFBQywwQkFBMEIsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBQ3pFLE9BQU8sRUFBQyxnQ0FBZ0MsRUFBQyxNQUFNLHNDQUFzQyxDQUFDO0FBQ3RGLE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLDhDQUE4QyxDQUFDO0FBQ2pGLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBRW5FOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLE9BQWdCLDZCQUE4QixTQUFRLDBCQUEwQjtJQUF0Rjs7UUFJRSw4RUFBOEU7UUFDOUUsbUZBQW1GO1FBQ25GLHFGQUFxRjtRQUM3RSxvQkFBZSxHQUFHLElBQUksMEJBQTBCLENBQ3RELElBQUksbUJBQW1CLENBQUMsRUFBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFDLENBQUMsRUFDakUsSUFBSSxDQUFDLEdBQUcsRUFDUixJQUFJLENBQUMsTUFBTSxFQUNYLElBQUksQ0FBQyxVQUFVLENBQ2hCLENBQUM7UUFDTSxr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LElBQUksa0JBQWtCLEVBQUUsQ0FBQztZQUN2QixhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDekMsQ0FBQztRQUVELE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUMxRCxNQUFNLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUV4RCxNQUFNLGFBQWEsR0FBRyxxQ0FBcUMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFbEYsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxDQUFDLDhCQUE4QixDQUFDLENBQUMsQ0FBQztRQUV6RSxJQUFJLHNCQUFzQixHQUN4Qix1REFBdUQ7WUFDdkQsR0FBRyxJQUFJLENBQUMsWUFBWSw0REFBNEQ7WUFDaEYsZ0VBQWdFO1lBQ2hFLElBQUksVUFBVSxhQUFhLFVBQVUsOENBQThDLENBQUM7UUFFdEYsTUFBTSxxQkFBcUIsR0FBRyxNQUFNLElBQUksQ0FBQyxxQ0FBcUMsQ0FDNUUsVUFBVSxFQUNWLHNCQUFzQixjQUFjLEVBQUUsRUFDdEMscURBQXFELGNBQWMsSUFBSSxFQUN2RSxzQkFBc0IsQ0FDdkIsQ0FBQztRQUVGLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxVQUFVLDRCQUE0QixDQUFDLENBQUMsQ0FBQztRQUVoRyxPQUFPLHFCQUFxQixDQUFDO0lBQy9CLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7Z3JlZW4sIExvZ30gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy5qcyc7XG5pbXBvcnQge3dvcmtzcGFjZVJlbGF0aXZlUGFja2FnZUpzb25QYXRofSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtSZWxlYXNlTm90ZXMsIHdvcmtzcGFjZVJlbGF0aXZlQ2hhbmdlbG9nUGF0aH0gZnJvbSAnLi4vLi4vLi4vbm90ZXMvcmVsZWFzZS1ub3Rlcy5qcyc7XG5pbXBvcnQge1B1bGxSZXF1ZXN0fSBmcm9tICcuLi8uLi9hY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGdldENvbW1pdE1lc3NhZ2VGb3JFeGNlcHRpb25hbE5leHRWZXJzaW9uQnVtcCxcbiAgZ2V0UmVsZWFzZU5vdGVDaGVycnlQaWNrQ29tbWl0TWVzc2FnZSxcbn0gZnJvbSAnLi4vLi4vY29tbWl0LW1lc3NhZ2UuanMnO1xuaW1wb3J0IHtDdXROcG1OZXh0UHJlcmVsZWFzZUFjdGlvbn0gZnJvbSAnLi4vY3V0LW5wbS1uZXh0LXByZXJlbGVhc2UuanMnO1xuaW1wb3J0IHtDdXROcG1OZXh0UmVsZWFzZUNhbmRpZGF0ZUFjdGlvbn0gZnJvbSAnLi4vY3V0LW5wbS1uZXh0LXJlbGVhc2UtY2FuZGlkYXRlLmpzJztcbmltcG9ydCB7QWN0aXZlUmVsZWFzZVRyYWluc30gZnJvbSAnLi4vLi4vLi4vdmVyc2lvbmluZy9hY3RpdmUtcmVsZWFzZS10cmFpbnMuanMnO1xuaW1wb3J0IHt1cGRhdGVSZW5vdmF0ZUNvbmZpZ30gZnJvbSAnLi4vcmVub3ZhdGUtY29uZmlnLXVwZGF0ZXMuanMnO1xuXG4vKipcbiAqIEJhc2UgYWN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gbW92ZSB0aGUgbmV4dCByZWxlYXNlLXRyYWluIGludG8gdGhlIGRlZGljYXRlZCBGRi9SQ1xuICogcmVsZWFzZS10cmFpbiB3aGlsZSBhbHNvIGN1dHRpbmcgYSByZWxlYXNlIHRvIG1vdmUgdGhlIHRyYWluIGludG8gdGhlIGBmZWF0dXJlLWZyZWV6ZWBcbiAqIG9yIGByZWxlYXNlLWNhbmRpZGF0ZWAgcGhhc2UuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGEgbmV3IHZlcnNpb24gYnJhbmNoIGlzIGNyZWF0ZWQgYmFzZWQgb24gdGhlIG5leHQgYnJhbmNoLCBhbmQgYSBuZXdcbiAqIHByZS1yZWxlYXNlIChlaXRoZXIgUkMgb3IgYW5vdGhlciBgbmV4dGApIGlzIGN1dC0gaW5kaWNhdGluZyB0aGUgbmV3IHBoYXNlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQnJhbmNoT2ZmTmV4dEJyYW5jaEJhc2VBY3Rpb24gZXh0ZW5kcyBDdXROcG1OZXh0UHJlcmVsZWFzZUFjdGlvbiB7XG4gIC8qKiBQaGFzZSB3aGljaCB0aGUgcmVsZWFzZS10cmFpbiBjdXJyZW50bHkgaW4gdGhlIGBuZXh0YCBwaGFzZSB3aWxsIG1vdmUgaW50by4gKi9cbiAgYWJzdHJhY3QgbmV3UGhhc2VOYW1lOiAnZmVhdHVyZS1mcmVlemUnIHwgJ3JlbGVhc2UtY2FuZGlkYXRlJztcblxuICAvLyBJbnN0YW5jZXMgb2YgdGhlIGFjdGlvbiBmb3IgY3V0dGluZyBhIE5QTSBuZXh0IHByZS1yZWxlYXNlcy4gV2Ugd2lsbCByZS11c2VcbiAgLy8gdGhlc2UgZm9yIGRldGVybWluaW5nIHRoZSBcIm5ldyB2ZXJzaW9uc1wiIGFuZCBcInJlbGVhc2Ugbm90ZXMgY29tcGFyaXNvbiB2ZXJzaW9uXCIuXG4gIC8vIFRoaXMgaGVscHMgYXZvaWRpbmcgZHVwbGljYXRpb24sIGVzcGVjaWFsbHkgc2luY2UgdGhlcmUgYXJlIGlzIHNvbWUgc3BlY2lhbCBsb2dpYy5cbiAgcHJpdmF0ZSBfbmV4dFByZXJlbGVhc2UgPSBuZXcgQ3V0TnBtTmV4dFByZXJlbGVhc2VBY3Rpb24oXG4gICAgbmV3IEFjdGl2ZVJlbGVhc2VUcmFpbnMoey4uLnRoaXMuYWN0aXZlLCByZWxlYXNlQ2FuZGlkYXRlOiBudWxsfSksXG4gICAgdGhpcy5naXQsXG4gICAgdGhpcy5jb25maWcsXG4gICAgdGhpcy5wcm9qZWN0RGlyLFxuICApO1xuICBwcml2YXRlIF9yY1ByZXJlbGVhc2UgPSBuZXcgQ3V0TnBtTmV4dFJlbGVhc2VDYW5kaWRhdGVBY3Rpb24oXG4gICAgbmV3IEFjdGl2ZVJlbGVhc2VUcmFpbnMoey4uLnRoaXMuYWN0aXZlLCByZWxlYXNlQ2FuZGlkYXRlOiB0aGlzLmFjdGl2ZS5uZXh0fSksXG4gICAgdGhpcy5naXQsXG4gICAgdGhpcy5jb25maWcsXG4gICAgdGhpcy5wcm9qZWN0RGlyLFxuICApO1xuXG4gIG92ZXJyaWRlIGFzeW5jIGdldERlc2NyaXB0aW9uKCkge1xuICAgIGNvbnN0IHticmFuY2hOYW1lfSA9IHRoaXMuYWN0aXZlLm5leHQ7XG4gICAgY29uc3QgbmV3VmVyc2lvbiA9IGF3YWl0IHRoaXMuX2NvbXB1dGVOZXdWZXJzaW9uKCk7XG4gICAgcmV0dXJuIGBNb3ZlIHRoZSBcIiR7YnJhbmNoTmFtZX1cIiBicmFuY2ggaW50byAke3RoaXMubmV3UGhhc2VOYW1lfSBwaGFzZSAodiR7bmV3VmVyc2lvbn0pLmA7XG4gIH1cblxuICBvdmVycmlkZSBhc3luYyBwZXJmb3JtKCkge1xuICAgIGNvbnN0IG5leHRCcmFuY2hOYW1lID0gdGhpcy5hY3RpdmUubmV4dC5icmFuY2hOYW1lO1xuICAgIGNvbnN0IGNvbXBhcmVWZXJzaW9uRm9yUmVsZWFzZU5vdGVzID0gYXdhaXQgdGhpcy5fY29tcHV0ZVJlbGVhc2VOb3RlQ29tcGFyZVZlcnNpb24oKTtcbiAgICBjb25zdCBuZXdWZXJzaW9uID0gYXdhaXQgdGhpcy5fY29tcHV0ZU5ld1ZlcnNpb24oKTtcbiAgICBjb25zdCBuZXdCcmFuY2ggPSBgJHtuZXdWZXJzaW9uLm1ham9yfS4ke25ld1ZlcnNpb24ubWlub3J9LnhgO1xuICAgIGNvbnN0IHtzaGE6IGJlZm9yZVN0YWdpbmdTaGF9ID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RDb21taXRPZkJyYW5jaChuZXh0QnJhbmNoTmFtZSk7XG5cbiAgICAvLyBWZXJpZnkgdGhlIGN1cnJlbnQgbmV4dCBicmFuY2ggaGFzIGEgcGFzc2luZyBzdGF0dXMsIGJlZm9yZSB3ZSBicmFuY2ggb2ZmLlxuICAgIGF3YWl0IHRoaXMuYXNzZXJ0UGFzc2luZ0dpdGh1YlN0YXR1cyhiZWZvcmVTdGFnaW5nU2hhLCBuZXh0QnJhbmNoTmFtZSk7XG5cbiAgICAvLyBCcmFuY2gtb2ZmIHRoZSBuZXh0IGJyYW5jaCBpbnRvIGEgbmV3IHZlcnNpb24gYnJhbmNoLlxuICAgIGF3YWl0IHRoaXMuX2NyZWF0ZU5ld1ZlcnNpb25CcmFuY2hGcm9tTmV4dChuZXdCcmFuY2gpO1xuXG4gICAgLy8gU3RhZ2UgdGhlIG5ldyB2ZXJzaW9uIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBicmFuY2gsIGFuZCBwdXNoIGNoYW5nZXMgdG8gYVxuICAgIC8vIGZvcmsgaW4gb3JkZXIgdG8gY3JlYXRlIGEgc3RhZ2luZyBwdWxsIHJlcXVlc3QuIE5vdGUgdGhhdCB3ZSByZS11c2UgdGhlIG5ld2x5XG4gICAgLy8gY3JlYXRlZCBicmFuY2ggaW5zdGVhZCBvZiByZS1mZXRjaGluZyBmcm9tIHRoZSB1cHN0cmVhbS5cbiAgICBjb25zdCB7cHVsbFJlcXVlc3QsIHJlbGVhc2VOb3RlcywgYnVpbHRQYWNrYWdlc1dpdGhJbmZvfSA9XG4gICAgICBhd2FpdCB0aGlzLnN0YWdlVmVyc2lvbkZvckJyYW5jaEFuZENyZWF0ZVB1bGxSZXF1ZXN0KFxuICAgICAgICBuZXdWZXJzaW9uLFxuICAgICAgICBjb21wYXJlVmVyc2lvbkZvclJlbGVhc2VOb3RlcyxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgKTtcblxuICAgIC8vIFdhaXQgZm9yIHRoZSBzdGFnaW5nIFBSIHRvIGJlIG1lcmdlZC4gVGhlbiBwdWJsaXNoIHRoZSBmZWF0dXJlLWZyZWV6ZSBuZXh0IHByZS1yZWxlYXNlLiBGaW5hbGx5LFxuICAgIC8vIGNoZXJyeS1waWNrIHRoZSByZWxlYXNlIG5vdGVzIGludG8gdGhlIG5leHQgYnJhbmNoIGluIGNvbWJpbmF0aW9uIHdpdGggYnVtcGluZyB0aGUgdmVyc2lvbiB0b1xuICAgIC8vIHRoZSBuZXh0IG1pbm9yIHRvby5cbiAgICBhd2FpdCB0aGlzLnByb21wdEFuZFdhaXRGb3JQdWxsUmVxdWVzdE1lcmdlZChwdWxsUmVxdWVzdCk7XG4gICAgYXdhaXQgdGhpcy5wdWJsaXNoKGJ1aWx0UGFja2FnZXNXaXRoSW5mbywgcmVsZWFzZU5vdGVzLCBiZWZvcmVTdGFnaW5nU2hhLCBuZXdCcmFuY2gsICduZXh0Jywge1xuICAgICAgc2hvd0FzTGF0ZXN0T25HaXRIdWI6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgY29uc3QgYnJhbmNoT2ZmUHVsbFJlcXVlc3QgPSBhd2FpdCB0aGlzLl9jcmVhdGVOZXh0QnJhbmNoVXBkYXRlUHVsbFJlcXVlc3QoXG4gICAgICByZWxlYXNlTm90ZXMsXG4gICAgICBuZXdWZXJzaW9uLFxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5wcm9tcHRBbmRXYWl0Rm9yUHVsbFJlcXVlc3RNZXJnZWQoYnJhbmNoT2ZmUHVsbFJlcXVlc3QpO1xuICB9XG5cbiAgLyoqIENvbXB1dGVzIHRoZSBuZXcgdmVyc2lvbiBmb3IgdGhlIHJlbGVhc2UtdHJhaW4gYmVpbmcgYnJhbmNoZWQtb2ZmLiAqL1xuICBwcml2YXRlIGFzeW5jIF9jb21wdXRlTmV3VmVyc2lvbigpOiBQcm9taXNlPHNlbXZlci5TZW1WZXI+IHtcbiAgICBpZiAodGhpcy5uZXdQaGFzZU5hbWUgPT09ICdmZWF0dXJlLWZyZWV6ZScpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZXh0UHJlcmVsZWFzZS5nZXROZXdWZXJzaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9yY1ByZXJlbGVhc2UuZ2V0TmV3VmVyc2lvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSByZWxlYXNlIG5vdGVzIGNvbXBhcmUgdmVyc2lvbiBmb3IgdGhlIGJyYW5jaGluZy1vZmYgcmVsZWFzZS4gKi9cbiAgcHJpdmF0ZSBhc3luYyBfY29tcHV0ZVJlbGVhc2VOb3RlQ29tcGFyZVZlcnNpb24oKTogUHJvbWlzZTxzZW12ZXIuU2VtVmVyPiB7XG4gICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgbmV3IHBoYXNlLCB0aGUgcmVsZWFzZSBub3RlcyBjb21wYXJlIHZlcnNpb24gc2hvdWxkXG4gICAgLy8gYWx3YXlzIGJlIHRoZSBvbmUgYXMgaWYgYSBwcmUtcmVsZWFzZSBpcyBjdXQgb24gdGhlIGBuZXh0YCBicmFuY2guXG4gICAgLy8gV2UgY2Fubm90IHJlbHkgb24gdGhlIGBDdXROcG1OZXh0UmVsZWFzZUNhbmRpZGF0ZUFjdGlvbmAgaGVyZSBiZWNhdXNlIGl0XG4gICAgLy8gYXNzdW1lcyBhIHB1Ymxpc2hlZCByZWxlYXNlIGZvciB0aGUgdHJhaW4uIFRoaXMgaXMgbm90IGd1YXJhbnRlZWQuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX25leHRQcmVyZWxlYXNlLnJlbGVhc2VOb3Rlc0NvbXBhcmVWZXJzaW9uO1xuICB9XG5cbiAgLyoqIENyZWF0ZXMgYSBuZXcgdmVyc2lvbiBicmFuY2ggZnJvbSB0aGUgbmV4dCBicmFuY2guICovXG4gIHByaXZhdGUgYXN5bmMgX2NyZWF0ZU5ld1ZlcnNpb25CcmFuY2hGcm9tTmV4dChuZXdCcmFuY2g6IHN0cmluZykge1xuICAgIGNvbnN0IHticmFuY2hOYW1lOiBuZXh0QnJhbmNofSA9IHRoaXMuYWN0aXZlLm5leHQ7XG4gICAgYXdhaXQgdGhpcy5jaGVja291dFVwc3RyZWFtQnJhbmNoKG5leHRCcmFuY2gpO1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlTG9jYWxCcmFuY2hGcm9tSGVhZChuZXdCcmFuY2gpO1xuICAgIGF3YWl0IHRoaXMucHVzaEhlYWRUb1JlbW90ZUJyYW5jaChuZXdCcmFuY2gpO1xuICAgIExvZy5pbmZvKGdyZWVuKGAgIOKckyAgIFZlcnNpb24gYnJhbmNoIFwiJHtuZXdCcmFuY2h9XCIgY3JlYXRlZC5gKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHB1bGwgcmVxdWVzdCBmb3IgdGhlIG5leHQgYnJhbmNoIHRoYXQgYnVtcHMgdGhlIHZlcnNpb24gdG8gdGhlIG5leHRcbiAgICogbWlub3IsIGFuZCBjaGVycnktcGlja3MgdGhlIGNoYW5nZWxvZyBmb3IgdGhlIG5ld2x5IGJyYW5jaGVkLW9mZiByZWxlYXNlLWNhbmRpZGF0ZVxuICAgKiBvciBmZWF0dXJlLWZyZWV6ZSB2ZXJzaW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfY3JlYXRlTmV4dEJyYW5jaFVwZGF0ZVB1bGxSZXF1ZXN0KFxuICAgIHJlbGVhc2VOb3RlczogUmVsZWFzZU5vdGVzLFxuICAgIG5ld1ZlcnNpb246IHNlbXZlci5TZW1WZXIsXG4gICk6IFByb21pc2U8UHVsbFJlcXVlc3Q+IHtcbiAgICBjb25zdCB7YnJhbmNoTmFtZTogbmV4dEJyYW5jaCwgdmVyc2lvbn0gPSB0aGlzLmFjdGl2ZS5uZXh0O1xuICAgIC8vIFdlIGluY3JlYXNlIHRoZSB2ZXJzaW9uIGZvciB0aGUgbmV4dCBicmFuY2ggdG8gdGhlIG5leHQgbWlub3IuIFRoZSB0ZWFtIGNhbiBkZWNpZGVcbiAgICAvLyBsYXRlciBpZiB0aGV5IHdhbnQgbmV4dCB0byBiZSBhIG1ham9yIHRocm91Z2ggdGhlIGBDb25maWd1cmUgTmV4dCBhcyBNYWpvcmAgcmVsZWFzZSBhY3Rpb24uXG4gICAgY29uc3QgbmV3TmV4dFZlcnNpb24gPSBzZW12ZXIucGFyc2UoYCR7dmVyc2lvbi5tYWpvcn0uJHt2ZXJzaW9uLm1pbm9yICsgMX0uMC1uZXh0LjBgKSE7XG4gICAgY29uc3QgYnVtcENvbW1pdE1lc3NhZ2UgPSBnZXRDb21taXRNZXNzYWdlRm9yRXhjZXB0aW9uYWxOZXh0VmVyc2lvbkJ1bXAobmV3TmV4dFZlcnNpb24pO1xuXG4gICAgYXdhaXQgdGhpcy5jaGVja291dFVwc3RyZWFtQnJhbmNoKG5leHRCcmFuY2gpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlUHJvamVjdFZlcnNpb24obmV3TmV4dFZlcnNpb24pO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGluZGl2aWR1YWwgY29tbWl0IGZvciB0aGUgbmV4dCB2ZXJzaW9uIGJ1bXAuIFRoZSBjaGFuZ2Vsb2cgc2hvdWxkIGdvIGludG9cbiAgICAvLyBhIHNlcGFyYXRlIGNvbW1pdCB0aGF0IG1ha2VzIGl0IGNsZWFyIHdoZXJlIHRoZSBjaGFuZ2Vsb2cgaXMgY2hlcnJ5LXBpY2tlZCBmcm9tLlxuICAgIGNvbnN0IGZpbGVzVG9Db21taXQ6IHN0cmluZ1tdID0gW1xuICAgICAgd29ya3NwYWNlUmVsYXRpdmVQYWNrYWdlSnNvblBhdGgsXG4gICAgICAuLi50aGlzLmdldEFzcGVjdExvY2tGaWxlcygpLFxuICAgIF07XG5cbiAgICBjb25zdCByZW5vdmF0ZUNvbmZpZ1BhdGggPSBhd2FpdCB1cGRhdGVSZW5vdmF0ZUNvbmZpZyh0aGlzLnByb2plY3REaXIsIG5leHRCcmFuY2gpO1xuICAgIGlmIChyZW5vdmF0ZUNvbmZpZ1BhdGgpIHtcbiAgICAgIGZpbGVzVG9Db21taXQucHVzaChyZW5vdmF0ZUNvbmZpZ1BhdGgpO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuY3JlYXRlQ29tbWl0KGJ1bXBDb21taXRNZXNzYWdlLCBmaWxlc1RvQ29tbWl0KTtcbiAgICBhd2FpdCB0aGlzLnByZXBlbmRSZWxlYXNlTm90ZXNUb0NoYW5nZWxvZyhyZWxlYXNlTm90ZXMpO1xuXG4gICAgY29uc3QgY29tbWl0TWVzc2FnZSA9IGdldFJlbGVhc2VOb3RlQ2hlcnJ5UGlja0NvbW1pdE1lc3NhZ2UocmVsZWFzZU5vdGVzLnZlcnNpb24pO1xuXG4gICAgYXdhaXQgdGhpcy5jcmVhdGVDb21taXQoY29tbWl0TWVzc2FnZSwgW3dvcmtzcGFjZVJlbGF0aXZlQ2hhbmdlbG9nUGF0aF0pO1xuXG4gICAgbGV0IG5leHRQdWxsUmVxdWVzdE1lc3NhZ2UgPVxuICAgICAgYFRoZSBwcmV2aW91cyBcIm5leHRcIiByZWxlYXNlLXRyYWluIGhhcyBtb3ZlZCBpbnRvIHRoZSBgICtcbiAgICAgIGAke3RoaXMubmV3UGhhc2VOYW1lfSBwaGFzZS4gVGhpcyBQUiB1cGRhdGVzIHRoZSBuZXh0IGJyYW5jaCB0byB0aGUgc3Vic2VxdWVudCBgICtcbiAgICAgIGByZWxlYXNlLXRyYWluLlxcblxcbkFsc28gdGhpcyBQUiBjaGVycnktcGlja3MgdGhlIGNoYW5nZWxvZyBmb3IgYCArXG4gICAgICBgdiR7bmV3VmVyc2lvbn0gaW50byB0aGUgJHtuZXh0QnJhbmNofSBicmFuY2ggc28gdGhhdCB0aGUgY2hhbmdlbG9nIGlzIHVwIHRvIGRhdGUuYDtcblxuICAgIGNvbnN0IG5leHRVcGRhdGVQdWxsUmVxdWVzdCA9IGF3YWl0IHRoaXMucHVzaENoYW5nZXNUb0ZvcmtBbmRDcmVhdGVQdWxsUmVxdWVzdChcbiAgICAgIG5leHRCcmFuY2gsXG4gICAgICBgbmV4dC1yZWxlYXNlLXRyYWluLSR7bmV3TmV4dFZlcnNpb259YCxcbiAgICAgIGBVcGRhdGUgbmV4dCBicmFuY2ggdG8gcmVmbGVjdCBuZXcgcmVsZWFzZS10cmFpbiBcInYke25ld05leHRWZXJzaW9ufVwiLmAsXG4gICAgICBuZXh0UHVsbFJlcXVlc3RNZXNzYWdlLFxuICAgICk7XG5cbiAgICBMb2cuaW5mbyhncmVlbihgICDinJMgICBQdWxsIHJlcXVlc3QgZm9yIHVwZGF0aW5nIHRoZSBcIiR7bmV4dEJyYW5jaH1cIiBicmFuY2ggaGFzIGJlZW4gY3JlYXRlZC5gKSk7XG5cbiAgICByZXR1cm4gbmV4dFVwZGF0ZVB1bGxSZXF1ZXN0O1xuICB9XG59XG4iXX0=