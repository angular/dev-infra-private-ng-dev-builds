import { existsSync } from 'node:fs';
import { green, Log } from '../../../utils/logging.js';
import { join } from 'node:path';
import { writeFile, readFile } from 'node:fs/promises';
import { targetLabels } from '../../../pr/common/labels/target.js';
/**
 * Updates the `renovate.json` configuration file to include a new base branch.
 * It also updates specific target labels within the package rules.
 *
 * @param projectDir - The path to the project directory.
 * @param newBranchName - The name of the new branch to add to the base branches list.
 * @returns A promise that resolves to the path of the modified `renovate.json` file if updated,
 * or `null` if the file was not found or the `baseBranches` array has an unexpected format.
 */
export async function updateRenovateConfig(projectDir, newBranchName) {
    const renovateConfigPath = join(projectDir, 'renovate.json');
    if (!existsSync(renovateConfigPath)) {
        Log.warn(`  ✘   Skipped updating Renovate config as it was not found.`);
        return null;
    }
    const config = await readFile(renovateConfigPath, 'utf-8');
    const configJson = JSON.parse(config);
    const baseBranches = configJson.baseBranches;
    if (!Array.isArray(baseBranches) || baseBranches.length !== 2) {
        Log.warn(`  ✘   Skipped updating Renovate config: "baseBranches" must contain exactly 2 branches.`);
        return null;
    }
    configJson.baseBranches = ['main', newBranchName];
    updateRenovateTargetLabel(configJson, targetLabels['TARGET_PATCH'].name, targetLabels['TARGET_RC'].name);
    await writeFile(renovateConfigPath, JSON.stringify(configJson, undefined, 2));
    Log.info(green(`  ✓   Updated Renovate config.`));
    return renovateConfigPath;
}
/**
 * Updates a specific target label in the `renovate.json` configuration file.
 * This function specifically targets and replaces one label with another within the `packageRules`.
 *
 * @param projectDir - The path to the project directory.
 * @param fromLabel - The label name to be replaced.
 * @param toLabel - The new label name to replace `fromLabel` with.
 * @returns A promise that resolves to the path of the modified `renovate.json` file if updated,
 * or `null` if the file was not found or the `baseBranches` array has an unexpected format.
 */
export async function updateRenovateConfigTargetLabels(projectDir, fromLabel, toLabel) {
    const renovateConfigPath = join(projectDir, 'renovate.json');
    if (!existsSync(renovateConfigPath)) {
        Log.warn(`  ✘   Skipped updating Renovate config as it was not found.`);
        return null;
    }
    const config = await readFile(renovateConfigPath, 'utf-8');
    const configJson = JSON.parse(config);
    // Check baseBranches just in case, though this function's primary focus is labels
    const baseBranches = configJson.baseBranches;
    if (!Array.isArray(baseBranches) || baseBranches.length !== 2) {
        Log.warn(`  ✘   Skipped updating Renovate config: "baseBranches" must contain exactly 2 branches.`);
        return null;
    }
    if (updateRenovateTargetLabel(configJson, fromLabel, toLabel)) {
        await writeFile(renovateConfigPath, JSON.stringify(configJson, undefined, 2));
        Log.info(green(`  ✓   Updated target label in Renovate config.`));
        return renovateConfigPath;
    }
    else {
        Log.info(green(`  ✓   No changes to target labels in Renovate config.`));
        return null;
    }
}
/**
 * Updates a specific target label within the `packageRules` of a Renovate configuration.
 *
 * @param configJson - The parsed JSON object of the Renovate configuration.
 * @param fromLabel - The label name to be replaced.
 * @param toLabel - The new label name to replace `fromLabel` with.
 * @returns `true` is the label has been updated, otherwise `false`.
 */
function updateRenovateTargetLabel(configJson, fromLabel, toLabel) {
    if (!Array.isArray(configJson.packageRules)) {
        return false;
    }
    let updated = false;
    for (const rule of configJson.packageRules) {
        if (!Array.isArray(rule.addLabels)) {
            continue;
        }
        const idx = rule.addLabels.findIndex((x) => x === fromLabel);
        if (idx >= 0) {
            rule.addLabels[idx] = toLabel;
            updated = true;
        }
    }
    return updated;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVub3ZhdGUtY29uZmlnLXVwZGF0ZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9uZy1kZXYvcmVsZWFzZS9wdWJsaXNoL2FjdGlvbnMvcmVub3ZhdGUtY29uZmlnLXVwZGF0ZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUNuQyxPQUFPLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQ3JELE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDL0IsT0FBTyxFQUFDLFNBQVMsRUFBRSxRQUFRLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUNyRCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0scUNBQXFDLENBQUM7QUFFakU7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLG9CQUFvQixDQUN4QyxVQUFrQixFQUNsQixhQUFxQjtJQUVyQixNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDN0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUM7UUFDcEMsR0FBRyxDQUFDLElBQUksQ0FBQyw2REFBNkQsQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELE1BQU0sTUFBTSxHQUFHLE1BQU0sUUFBUSxDQUFDLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzNELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUE0QixDQUFDO0lBQ2pFLE1BQU0sWUFBWSxHQUFHLFVBQVUsQ0FBQyxZQUFZLENBQUM7SUFFN0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFD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U0FBUyxDQUFDLENBQUM7UUFDM0UsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztZQUM5QixPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZXhpc3RzU3luY30gZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQge2dyZWVuLCBMb2d9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcuanMnO1xuaW1wb3J0IHtqb2lufSBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHt3cml0ZUZpbGUsIHJlYWRGaWxlfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJztcbmltcG9ydCB7dGFyZ2V0TGFiZWxzfSBmcm9tICcuLi8uLi8uLi9wci9jb21tb24vbGFiZWxzL3RhcmdldC5qcyc7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgYHJlbm92YXRlLmpzb25gIGNvbmZpZ3VyYXRpb24gZmlsZSB0byBpbmNsdWRlIGEgbmV3IGJhc2UgYnJhbmNoLlxuICogSXQgYWxzbyB1cGRhdGVzIHNwZWNpZmljIHRhcmdldCBsYWJlbHMgd2l0aGluIHRoZSBwYWNrYWdlIHJ1bGVzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0RGlyIC0gVGhlIHBhdGggdG8gdGhlIHByb2plY3QgZGlyZWN0b3J5LlxuICogQHBhcmFtIG5ld0JyYW5jaE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbmV3IGJyYW5jaCB0byBhZGQgdG8gdGhlIGJhc2UgYnJhbmNoZXMgbGlzdC5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwYXRoIG9mIHRoZSBtb2RpZmllZCBgcmVub3ZhdGUuanNvbmAgZmlsZSBpZiB1cGRhdGVkLFxuICogb3IgYG51bGxgIGlmIHRoZSBmaWxlIHdhcyBub3QgZm91bmQgb3IgdGhlIGBiYXNlQnJhbmNoZXNgIGFycmF5IGhhcyBhbiB1bmV4cGVjdGVkIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVJlbm92YXRlQ29uZmlnKFxuICBwcm9qZWN0RGlyOiBzdHJpbmcsXG4gIG5ld0JyYW5jaE5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICBjb25zdCByZW5vdmF0ZUNvbmZpZ1BhdGggPSBqb2luKHByb2plY3REaXIsICdyZW5vdmF0ZS5qc29uJyk7XG4gIGlmICghZXhpc3RzU3luYyhyZW5vdmF0ZUNvbmZpZ1BhdGgpKSB7XG4gICAgTG9nLndhcm4oYCAg4pyYICAgU2tpcHBlZCB1cGRhdGluZyBSZW5vdmF0ZSBjb25maWcgYXMgaXQgd2FzIG5vdCBmb3VuZC5gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWRGaWxlKHJlbm92YXRlQ29uZmlnUGF0aCwgJ3V0Zi04Jyk7XG4gIGNvbnN0IGNvbmZpZ0pzb24gPSBKU09OLnBhcnNlKGNvbmZpZykgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIGNvbnN0IGJhc2VCcmFuY2hlcyA9IGNvbmZpZ0pzb24uYmFzZUJyYW5jaGVzO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShiYXNlQnJhbmNoZXMpIHx8IGJhc2VCcmFuY2hlcy5sZW5ndGggIT09IDIpIHtcbiAgICBMb2cud2FybihcbiAgICAgIGAgIOKcmCAgIFNraXBwZWQgdXBkYXRpbmcgUmVub3ZhdGUgY29uZmlnOiBcImJhc2VCcmFuY2hlc1wiIG11c3QgY29udGFpbiBleGFjdGx5IDIgYnJhbmNoZXMuYCxcbiAgICApO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25maWdKc29uLmJhc2VCcmFuY2hlcyA9IFsnbWFpbicsIG5ld0JyYW5jaE5hbWVdO1xuXG4gIHVwZGF0ZVJlbm92YXRlVGFyZ2V0TGFiZWwoXG4gICAgY29uZmlnSnNvbixcbiAgICB0YXJnZXRMYWJlbHNbJ1RBUkdFVF9QQVRDSCddLm5hbWUsXG4gICAgdGFyZ2V0TGFiZWxzWydUQVJHRVRfUkMnXS5uYW1lLFxuICApO1xuICBhd2FpdCB3cml0ZUZpbGUocmVub3ZhdGVDb25maWdQYXRoLCBKU09OLnN0cmluZ2lmeShjb25maWdKc29uLCB1bmRlZmluZWQsIDIpKTtcblxuICBMb2cuaW5mbyhncmVlbihgICDinJMgICBVcGRhdGVkIFJlbm92YXRlIGNvbmZpZy5gKSk7XG4gIHJldHVybiByZW5vdmF0ZUNvbmZpZ1BhdGg7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHNwZWNpZmljIHRhcmdldCBsYWJlbCBpbiB0aGUgYHJlbm92YXRlLmpzb25gIGNvbmZpZ3VyYXRpb24gZmlsZS5cbiAqIFRoaXMgZnVuY3Rpb24gc3BlY2lmaWNhbGx5IHRhcmdldHMgYW5kIHJlcGxhY2VzIG9uZSBsYWJlbCB3aXRoIGFub3RoZXIgd2l0aGluIHRoZSBgcGFja2FnZVJ1bGVzYC5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdERpciAtIFRoZSBwYXRoIHRvIHRoZSBwcm9qZWN0IGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBmcm9tTGFiZWwgLSBUaGUgbGFiZWwgbmFtZSB0byBiZSByZXBsYWNlZC5cbiAqIEBwYXJhbSB0b0xhYmVsIC0gVGhlIG5ldyBsYWJlbCBuYW1lIHRvIHJlcGxhY2UgYGZyb21MYWJlbGAgd2l0aC5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwYXRoIG9mIHRoZSBtb2RpZmllZCBgcmVub3ZhdGUuanNvbmAgZmlsZSBpZiB1cGRhdGVkLFxuICogb3IgYG51bGxgIGlmIHRoZSBmaWxlIHdhcyBub3QgZm91bmQgb3IgdGhlIGBiYXNlQnJhbmNoZXNgIGFycmF5IGhhcyBhbiB1bmV4cGVjdGVkIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVJlbm92YXRlQ29uZmlnVGFyZ2V0TGFiZWxzKFxuICBwcm9qZWN0RGlyOiBzdHJpbmcsXG4gIGZyb21MYWJlbDogc3RyaW5nLFxuICB0b0xhYmVsOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgY29uc3QgcmVub3ZhdGVDb25maWdQYXRoID0gam9pbihwcm9qZWN0RGlyLCAncmVub3ZhdGUuanNvbicpO1xuICBpZiAoIWV4aXN0c1N5bmMocmVub3ZhdGVDb25maWdQYXRoKSkge1xuICAgIExvZy53YXJuKGAgIOKcmCAgIFNraXBwZWQgdXBkYXRpbmcgUmVub3ZhdGUgY29uZmlnIGFzIGl0IHdhcyBub3QgZm91bmQuYCk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWRGaWxlKHJlbm92YXRlQ29uZmlnUGF0aCwgJ3V0Zi04Jyk7XG4gIGNvbnN0IGNvbmZpZ0pzb24gPSBKU09OLnBhcnNlKGNvbmZpZykgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbiAgLy8gQ2hlY2sgYmFzZUJyYW5jaGVzIGp1c3QgaW4gY2FzZSwgdGhvdWdoIHRoaXMgZnVuY3Rpb24ncyBwcmltYXJ5IGZvY3VzIGlzIGxhYmVsc1xuICBjb25zdCBiYXNlQnJhbmNoZXMgPSBjb25maWdKc29uLmJhc2VCcmFuY2hlcztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGJhc2VCcmFuY2hlcykgfHwgYmFzZUJyYW5jaGVzLmxlbmd0aCAhPT0gMikge1xuICAgIExvZy53YXJuKFxuICAgICAgYCAg4pyYICAgU2tpcHBlZCB1cGRhdGluZyBSZW5vdmF0ZSBjb25maWc6IFwiYmFzZUJyYW5jaGVzXCIgbXVzdCBjb250YWluIGV4YWN0bHkgMiBicmFuY2hlcy5gLFxuICAgICk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1cGRhdGVSZW5vdmF0ZVRhcmdldExhYmVsKGNvbmZpZ0pzb24sIGZyb21MYWJlbCwgdG9MYWJlbCkpIHtcbiAgICBhd2FpdCB3cml0ZUZpbGUocmVub3ZhdGVDb25maWdQYXRoLCBKU09OLnN0cmluZ2lmeShjb25maWdKc29uLCB1bmRlZmluZWQsIDIpKTtcbiAgICBMb2cuaW5mbyhncmVlbihgICDinJMgICBVcGRhdGVkIHRhcmdldCBsYWJlbCBpbiBSZW5vdmF0ZSBjb25maWcuYCkpO1xuXG4gICAgcmV0dXJuIHJlbm92YXRlQ29uZmlnUGF0aDtcbiAgfSBlbHNlIHtcbiAgICBMb2cuaW5mbyhncmVlbihgICDinJMgICBObyBjaGFuZ2VzIHRvIHRhcmdldCBsYWJlbHMgaW4gUmVub3ZhdGUgY29uZmlnLmApKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzcGVjaWZpYyB0YXJnZXQgbGFiZWwgd2l0aGluIHRoZSBgcGFja2FnZVJ1bGVzYCBvZiBhIFJlbm92YXRlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHBhcmFtIGNvbmZpZ0pzb24gLSBUaGUgcGFyc2VkIEpTT04gb2JqZWN0IG9mIHRoZSBSZW5vdmF0ZSBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIGZyb21MYWJlbCAtIFRoZSBsYWJlbCBuYW1lIHRvIGJlIHJlcGxhY2VkLlxuICogQHBhcmFtIHRvTGFiZWwgLSBUaGUgbmV3IGxhYmVsIG5hbWUgdG8gcmVwbGFjZSBgZnJvbUxhYmVsYCB3aXRoLlxuICogQHJldHVybnMgYHRydWVgIGlzIHRoZSBsYWJlbCBoYXMgYmVlbiB1cGRhdGVkLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlUmVub3ZhdGVUYXJnZXRMYWJlbChcbiAgY29uZmlnSnNvbjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGZyb21MYWJlbDogc3RyaW5nLFxuICB0b0xhYmVsOiBzdHJpbmcsXG4pOiBib29sZWFuIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ0pzb24ucGFja2FnZVJ1bGVzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBjb25maWdKc29uLnBhY2thZ2VSdWxlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShydWxlLmFkZExhYmVscykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlkeCA9IChydWxlLmFkZExhYmVscyBhcyBzdHJpbmdbXSkuZmluZEluZGV4KCh4KSA9PiB4ID09PSBmcm9tTGFiZWwpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgcnVsZS5hZGRMYWJlbHNbaWR4XSA9IHRvTGFiZWw7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlZDtcbn1cbiJdfQ==