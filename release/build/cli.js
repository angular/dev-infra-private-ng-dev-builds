/**
 * @license
 * Copyright Google LLC
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { getConfig } from '../../utils/config.js';
import { green, Log } from '../../utils/logging.js';
import { assertValidReleaseConfig } from '../config/index.js';
import { BuildWorker } from './index.js';
/** Yargs command builder for configuring the `ng-dev release build` command. */
function builder(argv) {
    return argv.option('json', {
        type: 'boolean',
        description: 'Whether the built packages should be printed to stdout as JSON.',
        default: false,
    });
}
/** Yargs command handler for building a release. */
async function handler(args) {
    const config = await getConfig();
    assertValidReleaseConfig(config);
    const { npmPackages } = config.release;
    let builtPackages = await BuildWorker.invokeBuild();
    // If package building failed, print an error and exit with an error code.
    if (builtPackages === null) {
        Log.error(`  ✘   Could not build release output. Please check output above.`);
        process.exit(1);
    }
    // If no packages have been built, we assume that this is never correct
    // and exit with an error code.
    if (builtPackages.length === 0) {
        Log.error(`  ✘   No release packages have been built. Please ensure that the`);
        Log.error(`      build script is configured correctly in ".ng-dev".`);
        process.exit(1);
    }
    const missingPackages = npmPackages.filter((pkg) => !builtPackages.find((b) => b.name === pkg.name));
    // Check for configured release packages which have not been built. We want to
    // error and exit if any configured package has not been built.
    if (missingPackages.length > 0) {
        Log.error(`  ✘   Release output missing for the following packages:`);
        missingPackages.forEach((pkg) => Log.error(`      - ${pkg.name}`));
        process.exit(1);
    }
    if (args.json) {
        process.stdout.write(JSON.stringify(builtPackages, null, 2));
    }
    else {
        Log.info(green('  ✓   Built release packages.'));
        builtPackages.forEach(({ name }) => Log.info(green(`      - ${name}`)));
    }
}
/** CLI command module for building release output. */
export const ReleaseBuildCommandModule = {
    builder,
    handler,
    command: 'build',
    describe: 'Builds the release output for the current branch.',
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3JlbGVhc2UvYnVpbGQvY2xpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQVVILE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUNoRCxPQUFPLEVBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQ2xELE9BQU8sRUFBQyx3QkFBd0IsRUFBZSxNQUFNLG9CQUFvQixDQUFDO0FBRTFFLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFldkMsZ0ZBQWdGO0FBQ2hGLFNBQVMsT0FBTyxDQUFDLElBQVU7SUFDekIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtRQUN6QixJQUFJLEVBQUUsU0FBUztRQUNmLFdBQVcsRUFBRSxpRUFBaUU7UUFDOUUsT0FBTyxFQUFFLEtBQUs7S0FDZixDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsb0RBQW9EO0FBQ3BELEtBQUssVUFBVSxPQUFPLENBQUMsSUFBb0M7SUFDekQsTUFBTSxNQUFNLEdBQUcsTUFBTSxTQUFTLEVBQUUsQ0FBQztJQUNqQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqQyxNQUFNLEVBQUMsV0FBVyxFQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUNyQyxJQUFJLGFBQWEsR0FBRyxNQUFNLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUVwRCwwRUFBMEU7SUFDMUUsSUFBSSxhQUFhLEtBQUssSUFBSSxFQUFFLENBQUM7UUFDM0IsR0FBRyxDQUFDLEtBQUssQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO1FBQzlFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVELHVFQUF1RTtJQUN2RSwrQkFBK0I7SUFDL0IsSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQy9CLEdBQUcsQ0FBQyxLQUFLLENBQUMsbUVBQW1FLENBQUMsQ0FBQztRQUMvRSxHQUFHLENBQUMsS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7UUFDdEUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRUQsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FDeEMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsYUFBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQzFELENBQUM7SUFFRiw4RUFBOEU7SUFDOUUsK0RBQStEO0lBQy9ELElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUMvQixHQUFHLENBQUMsS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7UUFDdEUsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDZCxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUF5QixhQUFhLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkYsQ0FBQztTQUFNLENBQUM7UUFDTixHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLENBQUM7UUFDakQsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUMsSUFBSSxFQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEUsQ0FBQztBQUNILENBQUM7QUFFRCxzREFBc0Q7QUFDdEQsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQTJDO0lBQy9FLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTyxFQUFFLE9BQU87SUFDaEIsUUFBUSxFQUFFLG1EQUFtRDtDQUM5RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8vIC0tLS0gKipJTVBPUlRBTlQqKiAtLS0tXG4vLyBUaGlzIGNvbW1hbmQgaXMgcGFydCBvZiBvdXIgZXh0ZXJuYWwgY29tbWFuZHMgaW52b2tlZCBieSB0aGUgcmVsZWFzZSBwdWJsaXNoXG4vLyBjb21tYW5kLiBCZWZvcmUgbWFraW5nIGNoYW5nZXMsIGtlZXAgaW4gbWluZCB0aGF0IG1vcmUgcmVjZW50IGBuZy1kZXZgIHZlcnNpb25zXG4vLyBjYW4gc3RpbGwgaW52b2tlIHRoaXMgY29tbWFuZC5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pbXBvcnQge0FyZ3YsIEFyZ3VtZW50cywgQ29tbWFuZE1vZHVsZX0gZnJvbSAneWFyZ3MnO1xuXG5pbXBvcnQge2dldENvbmZpZ30gZnJvbSAnLi4vLi4vdXRpbHMvY29uZmlnLmpzJztcbmltcG9ydCB7Z3JlZW4sIExvZ30gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy5qcyc7XG5pbXBvcnQge2Fzc2VydFZhbGlkUmVsZWFzZUNvbmZpZywgQnVpbHRQYWNrYWdlfSBmcm9tICcuLi9jb25maWcvaW5kZXguanMnO1xuXG5pbXBvcnQge0J1aWxkV29ya2VyfSBmcm9tICcuL2luZGV4LmpzJztcblxuLyoqXG4gKiBUeXBlIGRlc2NyaWJpbmcgdGhlIEpTT04gb3V0cHV0IG9mIHRoaXMgY29tbWFuZC5cbiAqXG4gKiBAaW1wb3J0YW50IFdoZW4gY2hhbmdpbmcgdGhpcywgbWFrZSBzdXJlIHRoZSByZWxlYXNlIGFjdGlvblxuICogICBpbnZvY2F0aW9uIGlzIHVwZGF0ZWQgYXMgd2VsbC5cbiAqL1xuZXhwb3J0IHR5cGUgUmVsZWFzZUJ1aWxkSnNvblN0ZG91dCA9IEJ1aWx0UGFja2FnZVtdO1xuXG4vKiogQ29tbWFuZCBsaW5lIG9wdGlvbnMgZm9yIGJ1aWxkaW5nIGEgcmVsZWFzZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVsZWFzZUJ1aWxkT3B0aW9ucyB7XG4gIGpzb246IGJvb2xlYW47XG59XG5cbi8qKiBZYXJncyBjb21tYW5kIGJ1aWxkZXIgZm9yIGNvbmZpZ3VyaW5nIHRoZSBgbmctZGV2IHJlbGVhc2UgYnVpbGRgIGNvbW1hbmQuICovXG5mdW5jdGlvbiBidWlsZGVyKGFyZ3Y6IEFyZ3YpOiBBcmd2PFJlbGVhc2VCdWlsZE9wdGlvbnM+IHtcbiAgcmV0dXJuIGFyZ3Yub3B0aW9uKCdqc29uJywge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdGhlIGJ1aWx0IHBhY2thZ2VzIHNob3VsZCBiZSBwcmludGVkIHRvIHN0ZG91dCBhcyBKU09OLicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0pO1xufVxuXG4vKiogWWFyZ3MgY29tbWFuZCBoYW5kbGVyIGZvciBidWlsZGluZyBhIHJlbGVhc2UuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVyKGFyZ3M6IEFyZ3VtZW50czxSZWxlYXNlQnVpbGRPcHRpb25zPikge1xuICBjb25zdCBjb25maWcgPSBhd2FpdCBnZXRDb25maWcoKTtcbiAgYXNzZXJ0VmFsaWRSZWxlYXNlQ29uZmlnKGNvbmZpZyk7XG4gIGNvbnN0IHtucG1QYWNrYWdlc30gPSBjb25maWcucmVsZWFzZTtcbiAgbGV0IGJ1aWx0UGFja2FnZXMgPSBhd2FpdCBCdWlsZFdvcmtlci5pbnZva2VCdWlsZCgpO1xuXG4gIC8vIElmIHBhY2thZ2UgYnVpbGRpbmcgZmFpbGVkLCBwcmludCBhbiBlcnJvciBhbmQgZXhpdCB3aXRoIGFuIGVycm9yIGNvZGUuXG4gIGlmIChidWlsdFBhY2thZ2VzID09PSBudWxsKSB7XG4gICAgTG9nLmVycm9yKGAgIOKcmCAgIENvdWxkIG5vdCBidWlsZCByZWxlYXNlIG91dHB1dC4gUGxlYXNlIGNoZWNrIG91dHB1dCBhYm92ZS5gKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICAvLyBJZiBubyBwYWNrYWdlcyBoYXZlIGJlZW4gYnVpbHQsIHdlIGFzc3VtZSB0aGF0IHRoaXMgaXMgbmV2ZXIgY29ycmVjdFxuICAvLyBhbmQgZXhpdCB3aXRoIGFuIGVycm9yIGNvZGUuXG4gIGlmIChidWlsdFBhY2thZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIExvZy5lcnJvcihgICDinJggICBObyByZWxlYXNlIHBhY2thZ2VzIGhhdmUgYmVlbiBidWlsdC4gUGxlYXNlIGVuc3VyZSB0aGF0IHRoZWApO1xuICAgIExvZy5lcnJvcihgICAgICAgYnVpbGQgc2NyaXB0IGlzIGNvbmZpZ3VyZWQgY29ycmVjdGx5IGluIFwiLm5nLWRldlwiLmApO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxuXG4gIGNvbnN0IG1pc3NpbmdQYWNrYWdlcyA9IG5wbVBhY2thZ2VzLmZpbHRlcihcbiAgICAocGtnKSA9PiAhYnVpbHRQYWNrYWdlcyEuZmluZCgoYikgPT4gYi5uYW1lID09PSBwa2cubmFtZSksXG4gICk7XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbmZpZ3VyZWQgcmVsZWFzZSBwYWNrYWdlcyB3aGljaCBoYXZlIG5vdCBiZWVuIGJ1aWx0LiBXZSB3YW50IHRvXG4gIC8vIGVycm9yIGFuZCBleGl0IGlmIGFueSBjb25maWd1cmVkIHBhY2thZ2UgaGFzIG5vdCBiZWVuIGJ1aWx0LlxuICBpZiAobWlzc2luZ1BhY2thZ2VzLmxlbmd0aCA+IDApIHtcbiAgICBMb2cuZXJyb3IoYCAg4pyYICAgUmVsZWFzZSBvdXRwdXQgbWlzc2luZyBmb3IgdGhlIGZvbGxvd2luZyBwYWNrYWdlczpgKTtcbiAgICBtaXNzaW5nUGFja2FnZXMuZm9yRWFjaCgocGtnKSA9PiBMb2cuZXJyb3IoYCAgICAgIC0gJHtwa2cubmFtZX1gKSk7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9XG5cbiAgaWYgKGFyZ3MuanNvbikge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KDxSZWxlYXNlQnVpbGRKc29uU3Rkb3V0PmJ1aWx0UGFja2FnZXMsIG51bGwsIDIpKTtcbiAgfSBlbHNlIHtcbiAgICBMb2cuaW5mbyhncmVlbignICDinJMgICBCdWlsdCByZWxlYXNlIHBhY2thZ2VzLicpKTtcbiAgICBidWlsdFBhY2thZ2VzLmZvckVhY2goKHtuYW1lfSkgPT4gTG9nLmluZm8oZ3JlZW4oYCAgICAgIC0gJHtuYW1lfWApKSk7XG4gIH1cbn1cblxuLyoqIENMSSBjb21tYW5kIG1vZHVsZSBmb3IgYnVpbGRpbmcgcmVsZWFzZSBvdXRwdXQuICovXG5leHBvcnQgY29uc3QgUmVsZWFzZUJ1aWxkQ29tbWFuZE1vZHVsZTogQ29tbWFuZE1vZHVsZTx7fSwgUmVsZWFzZUJ1aWxkT3B0aW9ucz4gPSB7XG4gIGJ1aWxkZXIsXG4gIGhhbmRsZXIsXG4gIGNvbW1hbmQ6ICdidWlsZCcsXG4gIGRlc2NyaWJlOiAnQnVpbGRzIHRoZSByZWxlYXNlIG91dHB1dCBmb3IgdGhlIGN1cnJlbnQgYnJhbmNoLicsXG59O1xuIl19