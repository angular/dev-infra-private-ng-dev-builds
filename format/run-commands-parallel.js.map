{"version":3,"file":"run-commands-parallel.js","sourceRoot":"","sources":["run-commands-parallel.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Bar} from 'cli-progress';\nimport multimatch from 'multimatch';\nimport {cpus} from 'os';\n\nimport {ChildProcess, SpawnResult} from '../utils/child-process.js';\nimport {Log} from '../utils/logging.js';\n\nimport {Formatter, FormatterAction, getActiveFormatters} from './formatters/index.js';\n\n// Some environments, like CircleCI which use Docker report a number of CPUs by the host and not the count of available.\n// This causes the task to be killed when formatting a large number of files due lack of resources.\n// https://github.com/nodejs/node/issues/28762\nconst AVAILABLE_THREADS = Math.max(Math.min(cpus().length, 8) - 1, 1);\n\n/** Interface describing a failure occurred during formatting of a file. */\nexport interface FormatFailure {\n  /** Path to the file that failed. */\n  filePath: string;\n  /** Error message reported by the formatter. */\n  message: string;\n}\n\n/**\n * Run the provided commands in parallel for each provided file.\n *\n * Running the formatter is split across (number of available cpu threads - 1) processess.\n * The task is done in multiple processess to speed up the overall time of the task, as running\n * across entire repositories takes a large amount of time.\n * As a data point for illustration, using 8 process rather than 1 cut the execution\n * time from 276 seconds to 39 seconds for the same 2700 files.\n *\n * A promise is returned, completed when the command has completed running for each file.\n * The promise resolves with a list of failures, or `false` if no formatters have matched.\n */\nexport function runFormatterInParallel(allFiles: string[], action: FormatterAction) {\n  return new Promise<false | FormatFailure[]>(async (resolve) => {\n    const formatters = await getActiveFormatters();\n    const failures: FormatFailure[] = [];\n    const pendingCommands: {formatter: Formatter; file: string}[] = [];\n\n    for (const formatter of formatters) {\n      pendingCommands.push(\n        ...multimatch\n          .call(undefined, allFiles, formatter.getFileMatcher(), {dot: true})\n          .map((file) => ({formatter, file})),\n      );\n    }\n\n    // If no commands are generated, resolve the promise as `false` as no files\n    // were run against the any formatters.\n    if (pendingCommands.length === 0) {\n      return resolve(false);\n    }\n\n    switch (action) {\n      case 'format':\n        Log.info(`Formatting ${pendingCommands.length} file(s)`);\n        break;\n      case 'check':\n        Log.info(`Checking format of ${pendingCommands.length} file(s)`);\n        break;\n      default:\n        throw Error(`Invalid format action \"${action}\": allowed actions are \"format\" and \"check\"`);\n    }\n\n    // The progress bar instance to use for progress tracking.\n    const progressBar = new Bar({\n      format: `[{bar}] ETA: {eta}s | {value}/{total} files`,\n      clearOnComplete: true,\n    });\n    // A local copy of the files to run the command on.\n    // An array to represent the current usage state of each of the threads for parallelization.\n    const threads = new Array<boolean>(AVAILABLE_THREADS).fill(false);\n\n    // Recursively run the command on the next available file from the list using the provided\n    // thread.\n    function runCommandInThread(thread: number) {\n      const nextCommand = pendingCommands.pop();\n      // If no file was pulled from the array, return as there are no more files to run against.\n      if (nextCommand === undefined) {\n        threads[thread] = false;\n        return;\n      }\n\n      // Get the file and formatter for the next command.\n      const {file, formatter} = nextCommand;\n\n      const [spawnCmd, ...spawnArgs] = [...formatter.commandFor(action).split(' '), file];\n\n      ChildProcess.spawn(spawnCmd, spawnArgs, {\n        suppressErrorOnFailingExitCode: true,\n        mode: 'silent',\n      }).then(({stdout, stderr, status}: SpawnResult) => {\n        // Run the provided callback function.\n        const failed = formatter.callbackFor(action)(file, status, stdout, stderr);\n        if (failed) {\n          failures.push({filePath: file, message: stderr});\n        }\n        // Note in the progress bar another file being completed.\n        progressBar.increment(1);\n        // If more files exist in the list, run again to work on the next file,\n        // using the same slot.\n        if (pendingCommands.length) {\n          return runCommandInThread(thread);\n        }\n        // If not more files are available, mark the thread as unused.\n        threads[thread] = false;\n        // If all of the threads are false, as they are unused, mark the progress bar\n        // completed and resolve the promise.\n        if (threads.every((active) => !active)) {\n          progressBar.stop();\n          resolve(failures);\n        }\n      });\n      // Mark the thread as in use as the command execution has been started.\n      threads[thread] = true;\n    }\n\n    // Start the progress bar\n    progressBar.start(pendingCommands.length, 0);\n    // Start running the command on files from the least in each available thread.\n    threads.forEach((_, idx) => runCommandInThread(idx));\n  });\n}\n"]}