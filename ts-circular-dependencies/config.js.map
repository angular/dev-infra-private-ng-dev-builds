{"version":3,"file":"config.js","sourceRoot":"","sources":["config.ts"],"names":[],"mappings":"AAQA,OAAO,EAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,OAAO,EAAC,MAAM,MAAM,CAAC;AAE3D,OAAO,EAAC,GAAG,EAAC,MAAM,qBAAqB,CAAC;AAkCxC,MAAM,CAAC,KAAK,UAAU,cAAc,CAAC,UAAkB;IACrD,MAAM,aAAa,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;IAC1C,MAAM,mBAAmB,GAAG,CAAC,YAAoB,EAAE,EAAE,CAAC,OAAO,CAAC,aAAa,EAAE,YAAY,CAAC,CAAC;IAE3F,IAAI,CAAC;QACH,IAAI,MAAsC,CAAC;QAC3C,QAAQ,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC;YAC5B,KAAK,MAAM;gBAIT,MAAM,GAAG,MAAM,aAAa,CAAiC,UAAU,CAAC,CAAC;gBACzE,MAAM;YACR,KAAK,MAAM;gBACT,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;gBAC7B,MAAM;YACR;gBAGE,IAAI,CAAC;oBACH,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;gBAC/B,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACX,IAAK,CAAS,CAAC,IAAI,KAAK,iBAAiB,EAAE,CAAC;wBAI1C,MAAM,GAAG,MAAM,aAAa,CAAiC,UAAU,CAAC,CAAC;oBAC3E,CAAC;oBAED,MAAM,CAAC,CAAC;gBACV,CAAC;QACL,CAAC;QAGD,MAAM,GAAG,EAAC,GAAG,MAAM,EAAC,CAAC;QAErB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC;YAChC,MAAM,CAAC,OAAO,GAAG,mBAAmB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACvD,CAAC;QACD,IAAI,MAAM,CAAC,UAAU,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;YACxD,MAAM,CAAC,UAAU,GAAG,mBAAmB,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QAC7D,CAAC;QACD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;YAC7B,MAAM,CAAC,IAAI,GAAG,mBAAmB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACjD,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACX,GAAG,CAAC,KAAK,CAAC,6CAA6C,GAAG,UAAU,CAAC,CAAC;QACtE,GAAG,CAAC,KAAK,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC;QACnC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;AACH,CAAC;AAKD,IAAI,IAA+D,CAAC;AAcpE,MAAM,UAAU,aAAa,CAAI,UAAwB;IACvD,IAAI,KAAJ,IAAI,GAAK,IAAI,QAAQ,CAAC,YAAY,EAAE,4BAA4B,CAG/D,EAAC;IAEF,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC;AAC1B,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {dirname, extname, isAbsolute, resolve} from 'path';\n\nimport {Log} from '../utils/logging.js';\n\nimport {ModuleResolver} from './analyzer.js';\n\n/** Options used at runtime by the parser.  */\nexport interface CircularDependenciesParserOptions {\n  /** Whether to ignore type only imports in circular dependency checks. */\n  ignoreTypeOnlyChecks?: true;\n}\n\n/** Configuration for a circular dependencies test. */\nexport interface CircularDependenciesTestConfig extends CircularDependenciesParserOptions {\n  /** Base directory used for shortening paths in the golden file. */\n  baseDir: string;\n  /** Path to the golden file that is used for checking and approving. */\n  goldenFile?: string;\n  /** Glob that resolves source files which should be checked. */\n  glob: string;\n  /**\n   * Optional module resolver function that can be used to resolve modules\n   * to absolute file paths.\n   */\n  resolveModule?: ModuleResolver;\n  /**\n   * Optional command that will be displayed if the golden check failed. This can be used\n   * to consistently use script aliases for checking/approving the golden.\n   */\n  approveCommand?: string;\n}\n\n/**\n * Loads the configuration for the circular dependencies test. If the config cannot be\n * loaded, an error will be printed and the process exists with a non-zero exit code.\n */\nexport async function loadTestConfig(configPath: string): Promise<CircularDependenciesTestConfig> {\n  const configBaseDir = dirname(configPath);\n  const resolveRelativePath = (relativePath: string) => resolve(configBaseDir, relativePath);\n\n  try {\n    let config: CircularDependenciesTestConfig;\n    switch (extname(configPath)) {\n      case '.mjs':\n        // Load the ESM configuration file using the TypeScript dynamic import workaround.\n        // Once TypeScript provides support for keeping the dynamic import this workaround can be\n        // changed to a direct dynamic import.\n        config = await loadEsmModule<CircularDependenciesTestConfig>(configPath);\n        break;\n      case '.cjs':\n        config = require(configPath);\n        break;\n      default:\n        // The file could be either CommonJS or ESM.\n        // CommonJS is tried first then ESM if loading fails.\n        try {\n          config = require(configPath);\n        } catch (e) {\n          if ((e as any).code === 'ERR_REQUIRE_ESM') {\n            // Load the ESM configuration file using the TypeScript dynamic import workaround.\n            // Once TypeScript provides support for keeping the dynamic import this workaround can be\n            // changed to a direct dynamic import.\n            config = await loadEsmModule<CircularDependenciesTestConfig>(configPath);\n          }\n\n          throw e;\n        }\n    }\n\n    // Clone to config object. This is needed because in ESM the properties are non writeable\n    config = {...config};\n\n    if (!isAbsolute(config.baseDir)) {\n      config.baseDir = resolveRelativePath(config.baseDir);\n    }\n    if (config.goldenFile && !isAbsolute(config.goldenFile)) {\n      config.goldenFile = resolveRelativePath(config.goldenFile);\n    }\n    if (!isAbsolute(config.glob)) {\n      config.glob = resolveRelativePath(config.glob);\n    }\n    return config;\n  } catch (e) {\n    Log.error('Could not load test configuration file at: ' + configPath);\n    Log.error(`Failed with error:`, e);\n    process.exit(1);\n  }\n}\n\n/**\n * Lazily compiled dynamic import loader function.\n */\nlet load: (<T>(modulePath: string | URL) => Promise<T>) | undefined;\n\n/**\n * This uses a dynamic import to load a module which may be ESM.\n * CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript\n * will currently, unconditionally downlevel dynamic import into a require call.\n * require calls cannot load ESM code and will result in a runtime error. To workaround\n * this, a Function constructor is used to prevent TypeScript from changing the dynamic import.\n * Once TypeScript provides support for keeping the dynamic import this workaround can\n * be dropped.\n *\n * @param modulePath The path of the module to load.\n * @returns A Promise that resolves to the dynamically imported module.\n */\nexport function loadEsmModule<T>(modulePath: string | URL): Promise<T> {\n  load ??= new Function('modulePath', `return import(modulePath);`) as Exclude<\n    typeof load,\n    undefined\n  >;\n\n  return load(modulePath);\n}\n"]}