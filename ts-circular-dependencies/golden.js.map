{"version":3,"file":"golden.js","sourceRoot":"","sources":["golden.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {relative} from 'path';\n\nimport {ReferenceChain} from './analyzer.js';\nimport {convertPathToForwardSlash} from './file_system.js';\n\nexport type CircularDependency = ReferenceChain<string>;\nexport type Golden = CircularDependency[];\n\n/**\n * Converts a list of reference chains to a JSON-compatible golden object. Reference chains\n * by default use TypeScript source file objects. In order to make those chains printable,\n * the source file objects are mapped to their relative file names.\n */\nexport function convertReferenceChainToGolden(refs: ReferenceChain[], baseDir: string): Golden {\n  return (\n    refs\n      .map(\n        // Normalize cycles as the paths can vary based on which node in the cycle is visited\n        // first in the analyzer. The paths represent cycles. Hence we can shift nodes in a\n        // deterministic way so that the goldens don't change unnecessarily and cycle comparison\n        // is simpler.\n        (chain) =>\n          normalizeCircularDependency(\n            chain.map(({fileName}) => convertPathToForwardSlash(relative(baseDir, fileName))),\n          ),\n      )\n      // Sort cycles so that the golden doesn't change unnecessarily when cycles are detected\n      // in different order (e.g. new imports cause cycles to be detected earlier or later).\n      .sort(compareCircularDependency)\n  );\n}\n\n/**\n * Compares the specified goldens and returns two lists that describe newly\n * added circular dependencies, or fixed circular dependencies.\n */\nexport function compareGoldens(actual: Golden, expected: Golden) {\n  const newCircularDeps: CircularDependency[] = [];\n  const fixedCircularDeps: CircularDependency[] = [];\n  actual.forEach((a) => {\n    if (!expected.find((e) => isSameCircularDependency(a, e))) {\n      newCircularDeps.push(a);\n    }\n  });\n  expected.forEach((e) => {\n    if (!actual.find((a) => isSameCircularDependency(e, a))) {\n      fixedCircularDeps.push(e);\n    }\n  });\n  return {newCircularDeps, fixedCircularDeps};\n}\n\n/**\n * Normalizes the a circular dependency by ensuring that the path starts with the first\n * node in alphabetical order. Since the path array represents a cycle, we can make a\n * specific node the first element in the path that represents the cycle.\n *\n * This method is helpful because the path of circular dependencies changes based on which\n * file in the path has been visited first by the analyzer. e.g. Assume we have a circular\n * dependency represented as: `A -> B -> C`. The analyzer will detect this cycle when it\n * visits `A`. Though when a source file that is analyzed before `A` starts importing `B`,\n * the cycle path will detected as `B -> C -> A`. This represents the same cycle, but is just\n * different due to a limitation of using a data structure that can be written to a text-based\n * golden file.\n *\n * To account for this non-deterministic behavior in goldens, we shift the circular\n * dependency path to the first node based on alphabetical order. e.g. `A` will always\n * be the first node in the path that represents the cycle.\n */\nfunction normalizeCircularDependency(path: CircularDependency): CircularDependency {\n  if (path.length <= 1) {\n    return path;\n  }\n\n  let indexFirstNode: number = 0;\n  let valueFirstNode: string = path[0];\n\n  // Find a node in the cycle path that precedes all other elements\n  // in terms of alphabetical order.\n  for (let i = 1; i < path.length; i++) {\n    const value = path[i];\n    if (value.localeCompare(valueFirstNode, 'en') < 0) {\n      indexFirstNode = i;\n      valueFirstNode = value;\n    }\n  }\n\n  // If the alphabetically first node is already at start of the path, just\n  // return the actual path as no changes need to be made.\n  if (indexFirstNode === 0) {\n    return path;\n  }\n\n  // Move the determined first node (as of alphabetical order) to the start of a new\n  // path array. The nodes before the first node in the old path are then concatenated\n  // to the end of the new path. This is possible because the path represents a cycle.\n  return [...path.slice(indexFirstNode), ...path.slice(0, indexFirstNode)];\n}\n\n/** Checks whether the specified circular dependencies are equal. */\nfunction isSameCircularDependency(actual: CircularDependency, expected: CircularDependency) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] !== expected[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Compares two circular dependencies by respecting the alphabetic order of nodes in the\n * cycle paths. The first nodes which don't match in both paths are decisive on the order.\n */\nfunction compareCircularDependency(a: CircularDependency, b: CircularDependency): number {\n  // Go through nodes in both cycle paths and determine whether `a` should be ordered\n  // before `b`. The first nodes which don't match decide on the order.\n  for (let i = 0; i < Math.min(a.length, b.length); i++) {\n    const compareValue = a[i].localeCompare(b[i], 'en');\n    if (compareValue !== 0) {\n      return compareValue;\n    }\n  }\n  // If all nodes are equal in the cycles, the order is based on the length of both cycles.\n  return a.length - b.length;\n}\n"]}