{"version":3,"file":"analyzer.js","sourceRoot":"","sources":["analyzer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {readFileSync} from 'fs';\nimport {dirname, join, resolve} from 'path';\nimport ts from 'typescript';\nimport {CircularDependenciesParserOptions} from './config.js';\n\nimport {getFileStatus} from './file_system.js';\nimport {getModuleReferences} from './parser.js';\n\nexport type ModuleResolver = (specifier: string) => string | null;\n\n/**\n * Reference chains describe a sequence of source files which are connected through imports.\n * e.g. `file_a.ts` imports `file_b.ts`, whereas `file_b.ts` imports `file_c.ts`. The reference\n * chain data structure could be used to represent this import sequence.\n */\nexport type ReferenceChain<T = ts.SourceFile> = T[];\n\n/** Default extensions that the analyzer uses for resolving imports. */\nconst DEFAULT_EXTENSIONS = ['ts', 'js', 'd.ts'];\n\n/**\n * Analyzer that can be used to detect import cycles within source files. It supports\n * custom module resolution, source file caching and collects unresolved specifiers.\n */\nexport class Analyzer {\n  private _sourceFileCache = new Map<string, ts.SourceFile>();\n\n  private _ignoreTypeOnlyChecks: boolean;\n\n  unresolvedModules = new Set<string>();\n  unresolvedFiles = new Map<string, string[]>();\n\n  constructor(\n    public resolveModuleFn?: ModuleResolver,\n    ignoreTypeOnlyChecks: boolean = false,\n    public extensions: string[] = DEFAULT_EXTENSIONS,\n  ) {\n    this._ignoreTypeOnlyChecks = !!ignoreTypeOnlyChecks;\n  }\n\n  /** Finds all cycles in the specified source file. */\n  findCycles(\n    sf: ts.SourceFile,\n    visited = new WeakSet<ts.SourceFile>(),\n    path: ReferenceChain = [],\n  ): ReferenceChain[] {\n    const previousIndex = path.indexOf(sf);\n    // If the given node is already part of the current path, then a cycle has\n    // been found. Add the reference chain which represents the cycle to the results.\n    if (previousIndex !== -1) {\n      return [path.slice(previousIndex)];\n    }\n    // If the node has already been visited, then it's not necessary to go check its edges\n    // again. Cycles would have been already detected and collected in the first check.\n    if (visited.has(sf)) {\n      return [];\n    }\n    path.push(sf);\n    visited.add(sf);\n    // Go through all edges, which are determined through import/exports, and collect cycles.\n    const result: ReferenceChain[] = [];\n    for (const ref of getModuleReferences(sf, this._ignoreTypeOnlyChecks)) {\n      const targetFile = this._resolveImport(ref, sf.fileName);\n      if (targetFile !== null) {\n        result.push(...this.findCycles(this.getSourceFile(targetFile), visited, path.slice()));\n      }\n    }\n    return result;\n  }\n\n  /** Gets the TypeScript source file of the specified path. */\n  getSourceFile(filePath: string): ts.SourceFile {\n    const resolvedPath = resolve(filePath);\n    if (this._sourceFileCache.has(resolvedPath)) {\n      return this._sourceFileCache.get(resolvedPath)!;\n    }\n    const fileContent = readFileSync(resolvedPath, 'utf8');\n    const sourceFile = ts.createSourceFile(\n      resolvedPath,\n      fileContent,\n      ts.ScriptTarget.Latest,\n      false,\n    );\n    this._sourceFileCache.set(resolvedPath, sourceFile);\n    return sourceFile;\n  }\n\n  /** Resolves the given import specifier with respect to the specified containing file path. */\n  private _resolveImport(specifier: string, containingFilePath: string): string | null {\n    if (specifier.charAt(0) === '.') {\n      const resolvedPath = this._resolveFileSpecifier(specifier, containingFilePath);\n      if (resolvedPath === null) {\n        this._trackUnresolvedFileImport(specifier, containingFilePath);\n      }\n      return resolvedPath;\n    }\n    if (this.resolveModuleFn) {\n      const targetFile = this.resolveModuleFn(specifier);\n      if (targetFile !== null) {\n        const resolvedPath = this._resolveFileSpecifier(targetFile);\n        if (resolvedPath !== null) {\n          return resolvedPath;\n        }\n      }\n    }\n    this.unresolvedModules.add(specifier);\n    return null;\n  }\n\n  /** Tracks the given file import as unresolved. */\n  private _trackUnresolvedFileImport(specifier: string, originFilePath: string) {\n    if (!this.unresolvedFiles.has(originFilePath)) {\n      this.unresolvedFiles.set(originFilePath, [specifier]);\n    }\n    this.unresolvedFiles.get(originFilePath)!.push(specifier);\n  }\n\n  /** Resolves the given import specifier to the corresponding source file. */\n  private _resolveFileSpecifier(specifier: string, containingFilePath?: string): string | null {\n    const importFullPath =\n      containingFilePath !== undefined ? join(dirname(containingFilePath), specifier) : specifier;\n    const stat = getFileStatus(importFullPath);\n    if (stat && stat.isFile()) {\n      return importFullPath;\n    }\n    for (const extension of this.extensions) {\n      const pathWithExtension = `${importFullPath}.${extension}`;\n      const withExtensionStat = getFileStatus(pathWithExtension);\n      if (withExtensionStat?.isFile()) {\n        return pathWithExtension;\n      }\n    }\n    // Directories should be considered last. TypeScript first looks for source files, then\n    // falls back to directories if no file with appropriate extension could be found.\n    if (stat && stat.isDirectory()) {\n      return this._resolveFileSpecifier(join(importFullPath, 'index'));\n    }\n    return null;\n  }\n}\n"]}